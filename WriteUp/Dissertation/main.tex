% Template for a Computer Science Tripos Part II project dissertation
\documentclass[12pt,a4paper]{report}
% Gives a better chapter
\newcommand{\newchapter}[2]{
    \setcounter{chapter}{#1}
    \setcounter{section}{0}
    \chapter*{#2}
    \addcontentsline{toc}{chapter}{#1 #2}
}

\usepackage{titlesec}

\titleclass{\subsubsubsection}{straight}[\subsection]

\usepackage{dirtree}
\usepackage{scalerel}
\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}

\titleformat{\subsubsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
  {3.25ex \@plus1ex \@minus.2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
  {3.25ex \@plus1ex \@minus .2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@paragraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\makeatletter
\newenvironment{figurehere}
  {\def\@captype{figure}}
  {}
\makeatother
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage{verbatim}
\usepackage[utf8]{inputenc}
\usepackage{caption}
\captionsetup[table]{skip=0pt}
\captionsetup[figure]{skip=0pt}
\usepackage{placeins}
\captionsetup{justification=raggedright,singlelinecheck=false}
\usepackage[none]{hyphenat}
\usepackage{graphicx}				% Allows for photos to be added
%\usepackage{parskip} 				% Stops the horrific spacing 
\usepackage[top=0.5cm, foot=1.5em, bottom=2.5cm, left=2cm, right=2cm]{geometry} 	% Set margins to .5 inches 
\addtolength{\topmargin}{0.5in}		% Set top margin to 1 inch
\usepackage{hyperref}				% Hyperlinks package
\hypersetup{colorlinks=true, linkcolor=blue, citecolor = blue, filecolor=black, urlcolor=blue} 	% Make types of hyperlinks
\urlstyle{same}
\usepackage[none]{hyphenat}			% Stops it splitting words over two lines 

\renewcommand*\familydefault{\sfdefault} 
\usepackage{setspace}
\setstretch{1}
\usepackage{docmute}
\usepackage{tikz}
\usetikzlibrary{matrix,chains,positioning,decorations.pathreplacing,arrows, automata}

%\graphicspath{}			if you have trouble getting images in the thing, asks for graphics in the same folder
%\usepackage{hhline}         			% Horizontal lines in tables
\usepackage{siunitx}        			% Correct spacing of units
\usepackage{amsmath}        			% American Mathematical Society
\usepackage{amssymb}        			% Maths symbols
%\usepackage{amsthm}         			% Theorems
 \usepackage{lastpage}      			% ``n of m'' page numbering
%\usepackage{mathtools}
%\usepackage{changepage}
%\usepackage{blindtext}

\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000
\widowpenalty1000



\setlength{\parindent}{0pt} % get to fuck paragraph indent
\begin{document}

%%% TITLE PAGE %%%
\thispagestyle{empty}

\rightline{\LARGE Alexandra Riddell-Webster}

\vspace*{60mm}
\begin{center}
\Huge
\textbf{A System to Help Prevent Crashes in Rowing Boats} \\[5mm]
Computer Science Tripos -- Part II \\[5mm]
Murray Edwards College \\[5mm]
May 2023
\end{center}

%%% DECELERATION OF ORIGINALITY %%%
\pagestyle{plain}
\chapter*{Declaration of Originality}

I, Alexandra Riddell-Webster of Murray Edwards College, being a candidate for Part II of the Computer Science Tripos, hereby declare that this dissertation and the work described in it are my own work, unaided except as may be specified below, and that the dissertation does not contain material that has already been used to any substantial extent for a comparable purpose. In preparation of this dissertation I did not use text from AI-assisted platforms generating natural language answers to user queries, including but not limited to ChatGPT.\\ \\
I am content for my dissertation to be made available to the students and staff of the University. \\

\bigskip
\leftline{\textbf{Signed} }
\includegraphics[scale=0.35]{sig.jpg} \\
\leftline{\textbf{Date}} \\ 
May 11, 2023

%%% ACKNOWLEDGEMENTS %%%
\chapter*{Acknowledgements}
This dissertation owes a huge amount to Matthew Ireland, for supervising me. My UTO, Jon Crowcroft was invaluable. Thanks to the members of the Cambridge University Boat Club for allowing me to put strange boxes on their boats, advising me on communication over water and helping me evaluate the system. Special thanks to CUBC members Patrick Ryan, Mike Taylor, and Imogen Grant. I also thank Duncan Barnes for discussing GPS and electronics on rowing boats with me.


%%% PROFORMA %%%
\chapter*{Proforma}

{\large
\begin{tabular}{ll}
\bf Candidate Number:   & 2347C \\
\bf Project Title:  & A System to Help Prevent \\
& Crashes in Rowing Boats \\
\bf Examination:  & Computer Science Tripos -- Part II, May 2023      \\
\bf Word Count:    & 11332 \footnotemark[1]   \\
\bf Code Line Count:    & 6429 \footnotemark[2] \\ 
\bf Project Originator: & The Candidate     \\
\bf Supervisor:   & Mr Matthew Ireland  \\ 
\bf University Teaching Officer:  & Prof. Jon Crowcroft \\ 
\end{tabular}
}
\footnotetext[1]{Word count calculated with `\texttt{detex main.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w}' }
\stepcounter{footnote}
\footnotetext[2]{Line count calculated with `\texttt{cloc project --exclude-list-file=.clocignore}' where \texttt{.clocignore} contains the libraries I did not write}
\stepcounter{footnote}


\section*{Original Aims of the Project}
The objective of this project was to design a system to help prevent crashes in rowing boats. The goal of this system was to warn rowers and coxes when they approach obstacles, be they other boats or items in the river. This project also aimed to evaluate such a system.

\section*{Work Completed}
All core success criteria were met and some extension criteria implemented. \\ 
This project created such a system to help prevent crashes in rowing boats. Knowledge about obstacles was propagated through a mobile ad hoc network (MANET) of rowing boats using the Epidemic routing protocol. Users were warned when approaching a known obstacle by means of a buzzer and LED light. The MANET and system were thoroughly evaluated. \\
The whole system was documented and will be available, open-source, after my graduation. \\ 
\section*{Special Difficulties}
None.

%%% CONTENTS %%%
{
\hypersetup{linkcolor=black}
\tableofcontents
}

%%% INTRODUCTION %%%
\newchapter{1}{Introduction}
I built a system to help prevent crashes in rowing boats. The system is implemented in hardware, culminating in a series of boxes that can be attached to boats. The project is split into two parts; the mobile ad hoc network (MANET) that allows nodes to communicate a dynamic collection of known obstacles, then the application layer to warn users when they are approaching an obstacle and allows the user to add obstacles. The free and open-source software will be available online, fully documented, after my graduation. It includes a `how to' guide [\hyperref[appendixA]{Appendix A}] for the construction of a node so any rowing club can use my project as a collision avoidance tool. \\
The system this project produced achieved its goal. The system propagated obstacles through the network, warned users of upcoming obstacles, and allowed users to generate their own obstacles. \\

\section{Motivation}	
Crashes between rowing boats and obstacles or other boats injure rowers and cause equipment damage. Unfortunately, crashes are common. Figure 1.1 shows a boat on the Thames, having collided with a bridge at a regatta in March 2023. Some boats have coxswains, responsible for steering a boat, while others are coxless, where rowers who face away from the direction of travel are responsible for steering boats. This project is designed for use in both coxed and coxless boats. \\
My project has a very personal motivation, as a friend was hit by a larger rowing boat while in a single three years ago, causing a severe concussion that resulted in two years of intermission from their studies. \\
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{boatCrash.jpg.png}
\end{center}
\caption{An eight colliding with Barnes Bridge\textsuperscript{3}}
\end{figure}
\footnotetext[3]{Simon Ramskill, Twitter post, March 2023, \url{https://twitter.com/lliksmar/status/1637147870682906624?cxt=HHwWgIC8zY_UqLgtAAAA}, Accessed March 2023}
\stepcounter{footnote}

\subsection{Feedback from Users}
Olympian and Cambridge Student, Imogen Grant said
\emph{``Rowing is meant to be a non-contact sport, but it has a surprising incidence of concussions as a result of head on collisions, even at national and international level. We sit facing backwards, so steering involves looking over a shoulder in between strokes. The boats that I row in - singles and doubles - don't even have rudders and our steering is entirely reliant on pressure steering alone. Having warning of an obstacle would improve my confidence while sculling, and would mean that I could focus more on improving my technique rather than worrying that I might injure myself by crashing into something.''}


\section{Background}
% tell a better story here, it feels jerky with the jump from the first network to today 
\subsection{Networking}
The Defence Advanced Research Projects Agency (DARPA) Packet Radio Network (PRNET) \cite{prnet} was the first wireless data network, using store-and-forward routing over packet radios. Jubin and Tornow lay out the state of PRNET in 1987, nearly 15 years after research began on it, in their paper \emph{The DARPA Packet Radio Network Protocols}. The work on PRNET fed into DARPA's Survivable Radio Network (SURAN) \cite{suran}. This connection between the military and ad hoc networking still exists today, with MANETs used in conflicts \cite{military}, as well as autonomous vehicles \cite{vehicle} and disaster relief scenarios where previously existing infrastructure is destroyed \cite{disaster}. \\ \\
%As technology improved, radio cards were made available for personal computing in the 1990s 
Each node in a MANET is free to move  in any direction, so the topology of the network changes in an unpredictable way. Every node must also forward traffic, making it a router. \\
The nodes in my MANET would be rowing boats. Rowing boats frequently move at speeds greater than 15 km/h, making the topology of any network of boats unpredictable and dynamic. In addition to this, the network may move between rivers, meaning no existing infrastructure would be available. These form the primary challenge for my network; routing messages through the network without pre-existing infrastructure, and giving each node enough information to pass messages to other nodes. \\
This is made more difficult by the small CPU and memory on the Raspberry Pi Pico \cite{rp2040}, limiting the processing power and information each node has.  \\
\subsection{Medium Access Control}
While routing corresponds to many hops across a network, medium access control considers only one. Medium access control protocols manage access to the transmission media to prevent collisions between packets. Collisions could result in packets being corrupted and lower the overall utility of the network. This project implemented medium access control. \\
\subsection{OSI Model}
The Open Systems Interconnection (OSI) model for computer networking provides a standardisation for communication over a network. The OSI model consists of seven layers: Application, Presentation, Session, Transport, Network, Data Link, and Physical \cite{ib}. Based on this model, my project uses the libraries provided with hardware for the physical and data link layers. It focuses mainly on the networking layer, sending messages between nodes. \\

\section{Related Work}
\subsection{Networking}
There is precedent for using MANETs on rowing boats. I spoke to the team behind the broadcasting and telemetry for the Oxford Cambridge Boat Race. They use a 15-node MANET to get the video and telemetry from the rowing boats. They also take GPS readings for the location of the boat, recording the location up to 20 times a second. Figure 1.2 shows the equipment attached to the boats for the 2023 Boat Race.  
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.07]{boatrace1.jpg}           \includegraphics[scale=0.07]{boatrace2.jpg}
\end{center}
\caption{Equipment placed on the stern of the Cambridge boat \textsuperscript{4} }
\end{figure}

\footnotetext[4]{Photographs courtesy of Mike Taylor}
\stepcounter{footnote}

\subsection{Delay Tolerant Routing}
Delay tolerant routing assumes that networks will lack connectivity, with partitions between nodes. Vahdat and Becker's paper \emph{Epidemic Routing for Partially-Connected Ad Hoc Networks} \cite{epidemic} introduces a replication-based, delay-tolerant routing protocol where messages are passed onto nodes that do not have a copy of the message. Vahdat and Becker's paper is the key paper used to implement routing in this project. \\

\subsection{Safety in Rowing}
ROWCUS \cite{rowcus}, a company based in Switzerland, has attempted to solve the problem of crashes in rowing boats. While ROWCUS has similar goals to my project, the technical methodologies are different, using radar rather than GPS location to detect proximity to obstacles. Additionally, ROWCUS does not network nodes together, instead using individual nodes. ROWCUS has \emph{``decided not to pursue the commercial deployment of ROWCUS''}, in a statement on their website \cite{rowcus}. \\


%%% PREPARATION %%%
\newchapter{2}{Preparation}
\setcounter{figure}{0}
\section{Starting Point} 
I had no previous experience with microcontrollers, although I had worked with single-board computers. Therefore, over the summer I dedicated a small amount of time to learning about microcontrollers and MicroPython, completing basic tasks such as flashing an onboard LED. While this was useful, my project was eventually implemented in CircuitPython, so it would have been more beneficial to have researched CircuitPython. \\ \\
I had some experience with networking and routing protocols prior to starting this project. This was composed of the Part IB Networking module and two weeks' work during an internship on a MANET with a different routing protocol, much further abstracted than this project. During my project, I took the \emph{Part II Principles of Communications} course, further expanding my knowledge. \\

\section{Requirements}
The three requirements I identified as my success criteria were: \\ \\
\begin{tabular}{ll}
\textbf{The Epidemic routing protocol is implemented within the network}    & Achieved \\
\textbf{An evaluation of the network has been carried out}   & Achieved \\
\textbf{An application layer has been implemented to allow utility of the network}  & Achieved \\
\end{tabular} \\ \\
All of these requirements have been implemented during this project. \\ \\ 
I also laid out several extension tasks. The key extension was medium access control. Other extension tasks were drawn from my research into networking protocols other than Epidemic. For instance, using a metric of transmission quality -- received strength signal indicator (RSSI) in radio communication -- to influence whether an anti-entropy session is initiated. Additionally, the GPS location could be used, either by only contacting nearby nodes to increase the probability that an anti-entropy session is successful, or prioritising sending messages about new obstacles to nodes that are near these obstacles. While time constraints have not allowed me to implement all extensions, I have implemented two priorities of message, normal and urgent. \\

\subsection{Analysis}
The requirements for this project came from an analysis of the problem; they were building blocks for a system to help prevent crashes in rowing boats. Nodes would be attached to rowing boats, which have high mobility and frequently move at speeds around 15 km/h. The networks generated by rowing boats have a high chance of partition and are unpredictable. This topology required a high degree of flexibility within the network, pointing towards a delay-tolerant routing protocol. The limited computing power available was also a consideration. I chose to implement Epidemic as it is a delay-tolerant routing protocol and best suited to the network topology likely to be generated by rowing boats \cite{epidemic}. \\
As the nodes in the network were all going to communicate on the same medium, some medium access control would be needed to prevent collisions between messages. This was an extension criterion. \\

\subsection{Network Topology}
Many of the requirements were based on the topologies of networks generated by rowing boats. The potential topology of networks was analysed. This was done by looking at example distributions of rowing boats on lakes and rivers. I analysed Google Maps and Earth's satellite view of the Thames along a 5.5km stretch of the Championship Course, pinpointing rowing boats and coaching launches, adding them to a map with potential connections between nodes, assuming the radios have a range of 500m, alongside obstacles. Figure 2.1 shows a satellite image of two rowing boats, potential nodes in this network. Figure 2.2 shows the annotated map of the Thames, and Figure 2.3 presents the abstracted network topology of these rowing boats.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{earthSculler.jpg}
\end{center}
\caption{Two rowing boats seen on Google Earth \cite{earth}}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{mapsmarked.jpg}
\end{center}
\caption{Rowing boats, potential obstacles and assumed connections marked on a Google Maps map of the river Thames \cite{googlemapsgeneral}}
\end{figure}
\FloatBarrier
\begin{figurehere}
\begin{center}
\begin{tikzpicture}[bullet/.style={circle, fill, inner sep=2.5pt}]
    \foreach \lab [count=\c, 
                   evaluate=\c as \ang using {18+72*\c}] 
    in {a, b, c, d, e} {
       \node[bullet] (\c) at (\ang:10mm) {};
       \node at (\ang:14mm){};
       \foreach \i in {1,...,\c} {
          \draw[blue](\i)--(\c);
       }
    }
\node[bullet] (6) [right=of 5] {};
\node[bullet] (7) [right=of 6] {};
\draw[blue] (5) -- (6);
\draw[blue] (6) -- (7);
\node[bullet] (8) [right=5cm of 1] {};
\node[bullet] (9) [right= of 8] {};
\node[bullet] (10) [below= of 8] {};
\node[bullet] (11) [below= of 9] {};    
\draw[blue] (8) -- (9);
\draw[blue] (8) -- (10);
\draw[blue] (8) -- (11);
\draw[blue] (9) -- (10);
\draw[blue] (9) -- (11);
\draw[blue] (10) -- (11);
\node[bullet] (12) [right=8cm of 1] {};
\node[bullet] (13) [below =of 12] {};
\draw[blue] (12) -- (13); 
\end{tikzpicture}
\begin{tikzpicture}[bullet/.style={circle, fill, inner sep=2.5pt}]
    \foreach \lab [count=\c, 
                   evaluate=\c as \ang using {36+72*\c}] 
    in {a, b, c, d, e} {
       \node[bullet] (\c) at (\ang:10mm) {};
       \node at (\ang:14mm){};
       \foreach \i in {1,...,\c} {
          \draw[blue](\i)--(\c);
       }
    }
\node[bullet] (6) [right=of 5] {};
\node[bullet] (7) [right=of 4] {};
\node[bullet] (8) [right=4cm of 2] {};
\draw[blue] (5) -- (6);
\draw[blue] (6) -- (7);
\draw[blue] (6) -- (8);
\draw[blue] (4) -- (6);
\draw[blue] (5) -- (7);
\draw[blue] (6) -- (8);
\draw[blue] (7) -- (8);
\draw[blue] (4) -- (7); 
\node[bullet] (9) [right=3cm of 8] {};
\end{tikzpicture}
\end{center}
\caption{The network of rowing boats in an abstracted form, with nodes shown in black and assumed connections in blue }
\end{figurehere}
\FloatBarrier
\smallskip

\section{Summary of Research}
\subsection{MANETs}
A mobile ad hoc network (MANET) is characterised by wireless nodes, a frequently changing network topology and no reliance on pre-existing infrastructure. They are decentralised and therefore have no single point of failure \cite{d2}.  This project constructs a MANET between rowing boats to communicate obstacles to each other. A MANET was implemented due to the lack of pre-existing infrastructure for such a system and the difficulties associated with setting up and maintaining a base station or similar. Requiring an infrastructure like this would also raise the barrier to entry for many clubs with limited funds and technical skills. Additionally, rowing boats can move between stretches of water, further supporting the use of a MANET for this project. \\

\subsection{Routing}
Routing protocols find a path from a source to one or more destinations destination within the network. Different routing protocols optimise different parameters and are better suited for different network topologies and applications \cite{princom}. Within MANETs, a routing protocol must allow the network topology to change over time. They tend to contain node discovery techniques to allow for this. \\ \\
Before deciding on Epidemic routing for the project, several other protocols were considered. The Better Approach to Ad Hoc Mobile Networking (BATMAN) routing protocol \cite{batman} is designed to route messages through MANETs, broadcasting originator messages (OGM) for node discovery. BATMAN has the interesting addition of a transmit quality (TQ) metric in the OGM packets, allowing the quality of connections between nodes to be factored into the route packets take through the network. While BATMAN does allow messages to be broadcast to all nodes, its primary focus is routing messages from one node to another. Additionally, while it allows for message mobility, it is not delay-tolerant.\\ \\
Greedy Perimeter Stateless Routing (GPSR) is a location-based routing protocol \cite{gpsr}. GPSR exploits the relation between geographic position and connectivity in a wireless network, where each node tells its immediate neighbours its current location. Greedy forwarding is predominantly used to send packets to nodes that are progressively closer to the destination until the destination coordinates can be reached. Where greedy forwarding fails, GPSR uses perimeter forwarding (forwarding the packets around the perimeter of the region) until greedy forwarding can be used again. This protocol was ultimately deemed to be unsuitable for my project as, similar to BATMAN, its primary focus is on sending messages between two nodes. Additionally, the high mobility of nodes in the use case means forwarding packets to a set of coordinates does not guarantee the message will reach the intended destination, as the node may have moved.

\subsection{Epidemic Routing}
Epidemic routing was implemented as it is a delay-tolerant routing protocol and best suited to the network topology likely to be generated by rowing boats \cite{epidemic}. The networks generated by rowing boats have a high chance of partition, and the nodes are highly mobile. Epidemic routing allows all nodes to carry information through the network. This makes it useful for the topologies of the use case. Additionally, Epidemic routing supports a broadcast functionality, sending messages to every node in the network, which is necessary for the use case as every boat should hear about potential obstacles. \\
Epidemic routing gains its name from its similarity to the spreading of infections. Each node holds a buffer of messages that it has seen. When a node comes into contact with another node it has not recently contacted, it replicates and transmits messages to this neighbour. This message exchange is known as anti-entropy.

\subsubsection{Anti-Entropy}
The term `anti-entropy' is used in my dissertation as it is used in the associated literature, notably Vahdat and Becker's paper \cite{epidemic}. The term appears to have been coined in the 1987 paper \emph{Epidemic Algorithms for Replicated Database Maintenance} by Demers et all \cite{demers} and used in similar contexts by other papers. \\
In this dissertation, anti-entropy is the process of exchanging messages to pass them through the network. It is a key part of Epidemic routing. A more detailed explanation is in the Implementation chapter, although a brief overview is provided here.
When two nodes come into communication range, they transfer messages the other node has not seen to each other. Each node then stores these messages to exchange later. \\

\subsection{Medium Access Control}
While these routing protocols often have mechanisms to minimise the probability of collisions, such as adding a jitter in the sending of discovery messages, none of them contain medium access control. Due to the probability of collisions between messages causing disruption to the sending of messages, particularly as all nodes are broadcasting on the same radio frequency (433 MHz). It was  therefore prudent to include media access control in the system. \\
Multiple Access with Collision Avoidance for Wireless (MACAW) is often used by ad hoc networks \cite{macaw}. MACAW uses request to send (RTS) and clear to send (CTS) messages to minimise the probability of collision. As discussed in the System Design section, MACAW inspired the medium access control in my project. \\

\subsection{Serial Communication}
Serial communication protocols are used to transmit data between a microcontroller and peripherals. All data was transferred over relatively short distances. The two main protocols used in this project were the serial peripheral interface (SPI) and universal asynchronous transmitter / receiver (UART) protocols. 
\subsubsection{SPI}
SPI is a full duplex synchronous serial communication interface. The communication is synchronised by a clock signal, output from the controller on Serial Clock (SCLK). The four logic signals specified are SCLK, Peripheral Out Controller In (POCI), Peripheral In Controller Out (PICO), and Chip Select (CS). 
\begin{figurehere}
\begin{center}
\begin{tikzpicture}
[node/.style={rectangle, draw=black, very thick, minimum size=30mm}]
\node[node] (A) {};
\node[node] (B) [right =3cm of A] {};
\draw[-latex, line width=0.5mm, red] (A.30)--(A.30-|B.-150) node[left =3cm] {SCK} node[right]{SCK};
\draw[-latex, line width=0.5mm, blue] (A.10)--(A.10-|B.-150) node[left =3cm] {PICO} node[right]{PICO};
\draw[-latex, line width=0.5mm, green] (B.-170)--(A.-10) node[right = 3cm] {POCI} node[left]{POCI};
\draw[-latex, line width=0.5mm, gray] (A.-30)--(A.-30-|B.-150) node[left =3cm] {CS} node[right]{CS};
\end{tikzpicture}
\end{center}
\caption{SPI logic signals}
\end{figurehere}
\subsubsection{UART}
The UART protocol allows for full duplex, asynchronous communication. The controller and peripheral do not share a clock signal, but transmit at the same agreed speed. Data is transmitted using the UART frame format. 
\begin{figurehere}
\begin{center}
\begin{tikzpicture}
[node/.style={rectangle, draw=black, very thick, minimum size=18mm}]
\node[node] (A) {};
\node[node] (B) [right =3cm of A] {};
\draw[-latex, line width=0.5mm, red] (A.20)--(A.20-|B.-150) node[left =3cm] {TX} node[right]{RX};
\draw[-latex, line width=0.5mm, blue] (B.-165)--(A.-15) node[right = 3cm] {TX} node[left]{RX};
\end{tikzpicture}
\end{center}
\caption{UART logic signals}
\end{figurehere}

\section{Software Development}
\subsection{Methodology}
Most software development methodologies are designed for use within a team of programmers working over a long period and are not suited for a 
Part II project. I therefore integrated key components from several software development methodologies, particularly the waterfall and agile methodologies. \\ \\
The waterfall model of software development is based around the five stages: \\
\centerline{Requirements $\rightarrow$ System Design $\rightarrow$ Implementation $\rightarrow$ Testing $\rightarrow$ Maintenance} \\ \\
From the waterfall model of software development, I took the focus on planning and documentation, particularly as I wanted others to be able to reproduce my results. \\ \\ 
Agile software development is based on 12 principles that highlight responding to change and generating working software \cite{agile}. \\
I integrated the agile tenets \emph{``Simplicity -- the art of maximizing the amount of work not done -- is essential''} and \emph{``Welcome changing requirements, even late in development.''} into the project \cite{agilep}.  \\ \\ 
The work to be done was broken down into blocks, with concrete deliverables as criteria for completion of each block. This helped prevent scope creep and keep me on track for each part. I also tested each component of the project as it was built, ensuring that it worked and making debugging the final product easier.

\subsection{Programming}  
This project used CircuitPython, a branch of MicroPython, an implementation of Python 3 for microcontrollers. CircuitPython was used as it is easy to run on the Raspberry Pi Pico. Additionally, it allowed Pylint to be used to statically analyse code. This was particularly useful as the code was run on an external Raspberry Pi Pico, so running the code to find small errors would have been time consuming. Additionally, the existing AdaFruit libraries I used in the project were written in CircuitPython, so keeping the whole project in the same language reduced complexity. \\ \\
GitHub was used to perform version control on the code and dissertation for this project. This also allowed me to fork others' repositories and submit a pull request to AdaFruit. \\ \\ 
I used Visual Studio Code as my main integrated development environment (IDE) as I have used it in previous projects, and it offered support for CircuitPython via an extension.

\subsection{Licencing}
The project is licenced under the Massachusetts Institute of Technology (MIT) licence. All libraries used in the project are licenced under the same or more permissive licences. The MIT licence was chosen as it allows the project to use these libraries, and as it allows others to use and expand the system. \\

\section{Choice of Hardware}
The decision to build the system in hardware was not taken lightly. I was aware that it would bring challenges, unusual bugs and additional setup issues. However, it allowed proof that the project is viable and can be used. The hardware implementation allowed parameters to be more carefully tuned for a use case environment. Finally, the hardware implementation allowed a user interface evaluation.\\ \\
Hardware was ordered before the start of the Michaelmas term, in order to guarantee its availability for the project proposal. The main factors in my hardware choices were size, weight, power consumption and cost. A node needed to be relatively small to allow it to fit on a rowing boat. If components were overly expensive, the cost could prohibit other rowing clubs from producing their own networks. \\ \\
I chose to use a microcontroller to run the system due to the reduction in power consumption it would offer over a single-board computer. The Raspberry Pi Pico is a microcontroller with a dual-core Arm processor \cite{rp2040}. One unit costs Â£3.90 at the time of writing \cite{buypico}. The price factored into my choice of microcontroller so it would be affordable for most rowing clubs. It was also chosen due to its large peripheral set, with support for UART, SPI, and I2C protocols. This allowed greater flexibility throughout the project. Figure 2.6 shows the pinout for the Raspberry Pi Pico. \\
For GPS and radio, AdaFruit boards were chosen due to the strong community surrounding the hardware, and the boards being supported by open source libraries that allow rudimentary operations to be performed. \\
The AdaFruit RFM69 radio has an SPI interface and 500m range, appropriate for the use case as rowing boats will take around 2 minutes to cover 500m. Additionally, I chose to use the 433 MHz industrial, scientific, and medical (ISM) band as it is free to use without licencing, allowing me and other rowing clubs to use it without incurring additional costs. \\
The CD-PA1616S GPS has benefits similar to the RFM69, with community support and libraries for basic communication. It was additionally chosen as it includes a patch antenna and a relatively short cold start time -- these were important for the use case, as a delay in the collision avoidance device starting up reduces the overall utility of the system.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.25]{picopinout.png}
\end{center}
\caption{The pinout for the Raspberry Pi Pico\textsuperscript{5}}
\end{figure}
\footnotetext[5]{From Raspberry Pi, licenced under the Creative Commons Attribution-ShareAlike 4.0 licence \cite{pinout}}
\stepcounter{footnote}

\section{Timeline}
The Project Proposal laid out a timeline for the creation of the system, alongside milestones for completion of each part of the timeline [\hyperref[appendixC]{Appendix C}]. For the most part, this timeline was followed, with the exception of implementing the MANET, which took longer than the time allowed. Figure 2.7 shows a Gantt chart with the proposed and actual timelines.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.55]{gantt.pdf}
\end{center}
\caption{A Gantt chart with proposed and actual timelines}
\end{figure}



%%% IMPLEMENTATION %%%
\newchapter{3}{Implementation}
\setcounter{figure}{0}
% talk about the end of each stage where you tested the components 
%This chapter should describe what was actually produced: the programs which were written, the hardware which was built or the theory which was developed. 
% design strategies that looked ahead to the testing stage should be described in order to demonstrate a professional approach was taken.
%Descriptions of programs may include fragments of high-level code but large chunks of code are usually best left to appendices or omitted altogether. 
% Split into major blocks with the testing at the end ``It should not be necessary to give a day-by-day account of the progress of the work but major milestones may sometimes be highlighted with advantage.''
%Should definately make a new state machine / UML diagram to show how the code now works 
%On delays (back-off etc.) -- the delays currently seem quite long, and there'll need to be some justification in the Implementation chapter for how you chose the length of the delays. Usually I'd expect delays of the order of milliseconds rather than seconds. A sensible way to choose the delays would be: on your oscilloscope, time the total length of time required to complete one full exchange with another node, and then set the default back-off to that (and take a similar approach to any other delays in the program).
% talk about the name change
% They do assume you can program so don't overley detail how your code is structured.
% Highlight the requirements as you achieve them
% How are things scheduled on the pico? How is code compiled for the pico? 
% talk about how the project was implemented, starting with the system design and then implementing in blocks 

\section{Final System}
\subsection{Hardware}
Figure 3.1 shows a wiring diagram of the system, produced on Fritzing software, so others can replicate the system. Figure 3.2 shows a virtual breadboard with the system included, again so others can replicate it. Figure 3.3 is an image of the final system before it is contained in a box. I have soldered the Raspberry Pi Pico `upside down' so I can more easily view the pin numbers, so while the wiring in Figures 3.2 and 3.3 seems different at first glance, it is all the same. 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.8]{wiring.pdf}
\end{center}
\caption{Wiring digram for the system}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics{breadboard.pdf}
\end{center}
\caption{Virtual breadboard showing the system}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.141]{inBoxRuler.jpeg}    \includegraphics[scale=0.147]{outBoxRuler.jpeg}
\end{center}
\caption{The final system}
\end{figure}
\FloatBarrier

\subsection{Software}
Figure 3.4 shows the final state machine describing the software running on the Raspberry Pi Pico. The software differs slightly from what was designed, although both designs have the same effects. The software that was designed at the start is detailed below, under \emph{3.2 System Design}. This section discussed the final software that runs on the system. \\ 
Within my implementation of Epidemic routing, message exchange packets were merged with the medium access control packets to minimise the number of packets used in each anti-entropy session. This is detailed under section \emph{3.6 Epidemic Routing}. \\
Unfortunately, the libraries needed to interface with the hardware could not be ported to MicroPython. Therefore, the system was not multithreaded, instead running one thread. This is explored in section \emph{3.9 MicroPython}.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.45]{finalMachine.pdf}
\end{center}
\caption{The final state machine representation of the software}
\end{figure}
\FloatBarrier

\subsection{Packet Design}
The structure of the packets sent within the network was clearly defined. These structures are influenced by the structures of packets in previous routing protocols I researched. BATMAN was particularly influential, as it has a widely available and clearly documented implementation \cite{batman}. \\
Figures 3.5 and 3.6 show the overall design for packets sent on the network. I kept the preamble of all packet types identical so unwanted packets can easily be identified and dropped by a node. The preamble for all packet types starts with the length of the packet so the system knows how much data to expect. Figures 3.7 to 3.9 show the breakdown of the payload by packet type, given that the preamble is the same for all packets.  \\ \\
The address \verb'0x00' is designated for broadcast, then each node is given a unique address. This limits the number of nodes a network can contain to 255, which is sufficient for the use case as it is unlikely there will be this many boats on a river at once. 
\begin{figure}[h]
\begin{center}
\begin{tabular}{ |c|c|c|c|c| } 
\hline
\textbf{Bytes /} & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} \\ 
\textbf{Offset} &  &  &  &  \\ 
\hline
\textbf{0} & Length & Packet Type & Sender & Destination \\ 
\hline
\textbf{1} &     \multicolumn{4}{c|}{Payload}  \\ 
\hline
\textbf{2} &     \multicolumn{4}{c|}{Payload}  \\
\hline
 - & \multicolumn{4}{c|}{....................................}  \\
\hline
\textbf{14} & \multicolumn{4}{c|}{Payload}  \\
\hline
\textbf{15} & \multicolumn{4}{c|}{Payload}  \\
\hline
\end{tabular}
\end{center}
\caption{The preamble for all packet types}
\end{figure}

\begin{figure}[h]
\begin{center}
\begin{tabular}{ |c|c| } 
\hline
\textbf{Packet Type} &  \textbf{Hexadecimal Representation} \\
\hline
HELLO & \verb'0x00' \\ 
\hline
RTS &  \verb'0x01'  \\ 
\hline
CTS &   \verb'0x02'  \\
\hline
DATA &  \verb'0x03' \\
\hline
ACK &  \verb'0x04' \\
\hline
\end{tabular}
\end{center}
\caption{The types of packet}
\end{figure}


\begin{figure}[h]
\begin{center}
\begin{tabular}{ |c|c|c|c|c| }
\hline
\textbf{Bytes /} & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} \\ 
\textbf{Offset} &  &  &  &  \\ 
\hline
\textbf{1} &     \multicolumn{4}{c|}{GPS latitude}  \\ 
\hline
\textbf{2} &     \multicolumn{4}{c|}{GPS longitude}  \\
\hline
\textbf{3} &     \multicolumn{4}{c|}{Padding}  \\
\hline
 - & \multicolumn{4}{c|}{.........................................................}  \\
 \hline
\textbf{15} &     \multicolumn{4}{c|}{Padding}  \\
\hline
\end{tabular}
\end{center}
\caption{The payload of HELLO packet type}
\end{figure}

\begin{figure}[h]
\begin{center}\begin{tabular}{ |c|c|c|c|c| }
\hline
\textbf{Bytes /} & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} \\ 
\textbf{Offset} &  &  &  &  \\ 
\hline
\textbf{1} &     \multicolumn{2}{c|}{Message ID 0}  & \multicolumn{2}{c|}{Message ID 1}  \\ 
\hline
\textbf{2} &  \multicolumn{2}{c|}{Message ID 2}  & \multicolumn{2}{c|}{Message ID 3}   \\
\hline
 - & \multicolumn{4}{c|}{.........................................................}  \\
 \hline
 \textbf{14} &  \multicolumn{2}{c|}{Message ID 26}  & \multicolumn{2}{c|}{Message ID 27}   \\
\hline
\textbf{15} &   \multicolumn{2}{c|}{Message ID 28}  & \multicolumn{2}{c|}{Message ID 29}   \\
\hline
\end{tabular}
\end{center}
\caption{The payload of CTS and RTS packet types}
\end{figure}

\begin{figure}[h]
\begin{center}
\resizebox{\textwidth}{!}{\begin{tabular}{ |c|c|c|c|c| }
\hline
\textbf{Bytes /} & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} \\ 
\textbf{Offset} &  &  &  &  \\ 
\hline
\textbf{1} &   Total number of DATA packets expected  &  Number of this DATA packet & \multicolumn{2}{c|}{Requested Message ID 0} \\ 
\hline
\textbf{2} &  \multicolumn{4}{c|}{Requested Message Data}   \\
\hline
 - & \multicolumn{4}{c|}{.........................................................}  \\
 \hline
 \textbf{14} &  \multicolumn{2}{c|}{Requested Message Data}  & \multicolumn{2}{c|}{Requested Message ID 7}   \\
\hline
\textbf{15} & \multicolumn{4}{c|}{Requested Message Data} \\
\hline
\end{tabular}}
\end{center}
\caption{The payload of DATA packet types}
\end{figure}
\FloatBarrier

\subsection{Open Source}
The system was designed and documented so it could be reproduced by other rowing clubs and used to help prevent crashes. This allows it to be used by other rowing clubs without needing to go through compliance testing and other certification. Due to the University's plagiarism rules, the repositories and documentation have not yet been made available. They will be made public immediately after my graduation. \\
The repository is licenced under the MIT licence, allowing others to use and expand on the system. \\ \\
\bigskip


\section{System Design}
This section details the system that was designed at the start of the project. The software changed slightly in development and the final system is above, in \emph{3.1 Final System}. \\
Before designing the system, it was decided the system would identify obstacles using GPS coordinates. The Epidemic routing protocol would be used to propagate obstacles through the network. Users need to be notified of upcoming obstacles and be able to add new obstacles. \\
From these criteria, the structure of the software to run on each node was designed. The Raspberry Pi Pico uses the RP2040 chip, an ARM based dual-core chip with 264kB of SRAM \cite{rp2040}. To best use the hardware, application and networking threads were designed to run on each core. Global data structures and concurrency control were chosen to pass messages between the two layers and allow both layers access to the GPS. \\ 


\subsection{Application}
The application thread was responsible for notifying the user when they are too close to an obstacle and allowing them to add obstacles. The initial state machine is shown in Figure 3.10. 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{app.pdf}
\end{center}
\caption{The initial state machine for the application thread}
\end{figure}
\FloatBarrier

\subsection{Networking}
% literially anything about the flooding state machine thing
The networking thread was designed to propagate messages through the network. It contained the implementation of Epidemic with medium access control. While routing and medium access control are typically handled separately -- in the OSI model they are in the second and third layers respectively -- they were considered together in this system to prevent work from being repeated and use limited computing resources effectively. These traditionally separate layers were combined as some data structures, such as the contacted node dictionary, need to be shared between layers, increasing complexity and compute time. This merging of layers meant Vahdat and Becker's implementation of Epidemic was adjusted. A quiet state was defined, where a node did not send any messages after hearing a CTS for a set period of time, or until it hears an ACK. The message vector exchange was combined into the CTS and RTS messages. This minimised the number of packets sent over the network, reducing the probability of collisions or errors in transmission.  Figure 3.11 shows the Networking machine.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{appLayer.pdf}
\end{center}
\caption{The initial state machine for the networking thread}
\end{figure}
\FloatBarrier

\subsection{Data Structures}
\subsubsection{Global}
The global data structures would be accessed by both threads, with associated locks to ensure that both threads do not access the structure at the same time. \\ \\
\resizebox{\textwidth}{!}{\begin{tabular}{ l l l }
\hline
\textbf{Structure} & \textbf{Construction} & \textbf{Notes} \\  
\hline
Location & Tuple of (longitude, latitude) &  Calls a function that communicates with \\
& & the GPS board \\ 
\hline
ApplicationToNetwork & Queue of obstacles &  Application machine pushes user defined \\
& & obstacles onto queue so they can be \\
& & propagated through the network\\ 
\hline
NetworkToApplication & Queue of obstacles & Network machine pushes messages propagated \\
& & through the network to the application layer\\ 
\hline
\end{tabular}}


% The initial idea here is to for a routing or application layer to push data onto the queue
% The network layer tkaes care of deduplication?
% like 10 pages and 2000 words coming on ouch 
\subsubsection{Application}
\resizebox{\textwidth}{!}{\begin{tabular}{ l l l }
\hline
\textbf{Structure} & \textbf{Construction} & \textbf{Notes} \\  
\hline
Obstacles & List of obstacles and their TTL & A list of obstacles and their TTL. Any obstacles\\
& &   with a TTL of -1 are considered permanent \\
\hline
\end{tabular}}

\subsubsection{Networking}
\resizebox{\textwidth}{!}{\begin{tabular}{ l l l }
\hline
\textbf{Structure} & \textbf{Construction} & \textbf{Notes} \\  
\hline
Messages & Dictionary of & The messages' ID is constructed from the \\
& \{Message ID : [Latitude, Longitude, TTL]\}  &  generating node ID and the number of messages \\
& &  that node has generated\\ 
\hline
\end{tabular}}
\FloatBarrier

\section{Debugging}
Throughout the project, various pieces of hardware and communication issues needed to be debugged. To debug these, a multimeter was used to measure the voltage and therefore signal sent over various connections. On occasions when the multimeter could not be accessed, the anode of an LED was attached to the connection being examined and the cathode grounded. The LED would light up when current was passing through this connection. \\
When debugging more persistent issues, such as the MicroPython-CircuitPython communication, my supervisor kindly lent me a logic analyser. Figure 3.12 shows a node being examined with a logic analyser. \\ \\ 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.2]{logicAnalyser.jpeg}
\end{center}
\caption{A logic analyser being used to examine the signals sent from the Raspberry Pi Pico to the RMF69}
\end{figure}


\section{Logging}
Logging was done via a bespoke class. The class had functions to handle different events. It generated a series of statements that were flash memory on the Pico in a \verb'logging.txt' file and printed to the terminal if the device was connected to a computer. This made debugging any problems easier and allowed straightforward modelling of the relationships between nodes. The docstring from the logging class reads:\begin{verbatim}
Class with multiple functions to handle logging
    
Logs: 
    Node Address, Time, Time Since Node Startup, Event Type, Event Information

Event Types:
    0   -   General logging string
    1   -   Logging function
    2   -   Logging packet
    3   -   Logging messages
    4   -   Logging error
    5   -   Logging GPS location
    6   -   Logging an alert
    
\end{verbatim}


\section{Point to Point}
Before starting to implement Epidemic routing, I ensured that the two nodes in line of sight could communicate. This was successful; each node could send a packet to another node. Several interesting variables were found in the communication between point to point nodes. \\ \\
A quarter wave whip antenna was used -- a piece of wire cut to 17.4 cm (1/4 of the wavelength) and soldered to the antenna port and ground plane. I found that the thickness of the antenna wire had an impact on the signal, with a thicker wire having a longer range. This is likely due to the lower resistance of the thicker wire. Figure 3.13 shows the antenna of varying thickness on three of the radio. The antennae were one of the main practical difficulties that came from implementing the system in hardware. They had a tendency to break or fall off and a small error in application results in a significant reduction in communication range. \\ \\
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.1]{wires1.jpeg}           \includegraphics[scale=0.12]{wires2.jpeg}
\end{center}
\caption{A selection of antenna on the radios}
\end{figure}
It was also found that when the rate and length of packets sent increased, more errors occurred in transmission and decoding. To fix this, I wanted to move to fixed length packets. However, the \verb'adafruit_rfm69' library did not allow for fixed length packets. I therefore added this functionality. I consulted the RFM69HCW datasheet \cite{radiodata}, set the packet format register to 0 (indicating fixed length), and the packet length to 64 (the size of the FIFO buffer). Additionally, I integrated fixed length packets into a fork of the \verb'adafruit_rfm69' library \cite{radiogit} and submitted a pull request so others can use this functionality. \\

\section{Epidemic Routing}
\subsection{Node Discovery}
The point to point packets were used as the basis for node discovery messages, of type \verb'0x00', also called HELLO packets. These packets were broadcast and used the structure defined in section \emph{3.1 Final System}. To test node discovery, I checked that HELLO packets were correctly sent and received. The payload of HELLO packets contained the node's current GPS location, so it could be recognised as an obstacle by other nodes. When first initiated, this location was generated by a stand-in function that gave a random set of numbers, later replaced by a call to the GPS board. I made sure that the location contained in any HELLO packets a node received was added to the list of obstacles. 

\subsection{Anti-Entropy}
When a new node is discovered via HELLO packet, anti-entropy will occur. Anti-entropy is the mechanism by which a node (A) determines what messages another node (B) holds that A has not seen and exchanges these messages. An anti-entropy session resolves any differences in the messages held by the two nodes and occurs when two nodes are in communication range. \\
Anti-entropy in the context of Epidemic routing is first defined by Vahdat and Becker, in their paper \emph{Epidemic Routing for Partially-Connected Ad Hoc Networks} \cite{epidemic}. Some aspects of their anti-entropy session were not suitable for this project, so have been changed. This dissertation first lays out how Vahdat and Becker implemented anti-entropy, then my project's implementation. 

\subsubsection{In Literature}
In Vahdat and Becker's Epidemic routing paper \cite{epidemic}, anti-entropy is initiated by the node with the lower ID to prevent collisions. Figure 3.14 shows the first half of anti-entropy. Node A, with a lower ID, initiates anti-entropy by sending a summary vector (SV\textsubscript{A}) to node B. This summary vector represents the messages node A holds. Node B calculates the logical AND between this summary vector and the negation of its own summary vector (SV\textsubscript{B}) to produce the messages it has not seen, but the other node holds. It sends this request (SV\textsubscript{A}  $\wedge \neg$ SV\textsubscript{B}) to node A. Node A responds by sending the requested messages to node B. \\
The roles are then reversed, with node B sending its summary vector (SV\textsubscript{B}) to A. A requests messages it has not seen from B (SV\textsubscript{B} $\wedge \neg$ SV\textsubscript{A}) and receives them. \\
If anti-entropy succeeds, B is added to A's list of recently contacted nodes, preventing anti-entropy from being repeatedly conducted between two nodes. This list is periodically cleared. \\ \\
I am unsure why the nodes send both a summary vector and a request calculated from the summary vector. It sends more packets than needed while not saving on any computing time, as both nodes must compute a request. Therefore this was changed in the project's implementation of Epidemic routing. Vahdat and Becker imply it allows each node to retain autonomy in which messages they request and therefore hold, for instance only requesting messages under a certain size. This is not a concern in this project as all messages are of the same size. Additionally, if a node does not want to hold a message, it drops it.
\begin{figurehere} 
\begin{center}
\begin{tikzpicture}
[node/.style={circle, draw=black, very thick, minimum size=25mm}]
\node[node]      (A)         {\Huge A};
\node[node]        (B)    [right =3cm of A]   {\Huge B};
\draw[-latex, line width=0.5mm, blue] (A.30)--(A.30-|B.-150) node[midway, above] {SV\textsubscript{A}};
\draw[-latex, line width=0.5mm, red] (B)--(A) node[midway, above] {SV\textsubscript{A} $\wedge \neg$ SV\textsubscript{B}};
\draw[-latex, line width=0.5mm, blue] (A.-30)--(A.-30-|B.-150) node[midway, above] {Messages};
\end{tikzpicture}
\end{center}
\caption{The first stage of anti-entropy \cite{epidemic}}
\end{figurehere} 
\bigskip

\subsubsection{In the Project}
The implementation of Epidemic routing in this project is broadly the same as Vahdat and Becker's. A session is initiated by the lower ID node. However, the implementation in this project combines medium access control with the exchange of summary vectors, with SV\textsubscript{A} being combined with the RTS and SV\textsubscript{B} combined with CTS. These contained the message keys that are held on that node. This is done to reduce the number of messages sent in each anti-entropy exchange. \\
The other difference is requests. As mentioned above, all nodes use the same mechanism to construct a request, so this can be constructed on the node that will send messages. Once a node has received the summary vector from the other node, it will calculate the messages the node wants by comparing the message keys each node holds (SV\textsubscript{A} $\wedge \neg$ SV\textsubscript{B}). This removes two messages from the anti-entropy process, reducing the opportunity for error. Figure 3.15 shows this implementation of anti-entropy.

\begin{figurehere} 
\begin{center}
\begin{tikzpicture}
[node/.style={circle, draw=black, very thick, minimum size=30mm}]
\node[node]      (A)         {\Huge A};
\node[node]        (B)    [right =3cm of A]   {\Huge B};
\draw[-latex, line width=0.5mm, blue] (A.60)--(A.60-|B.-120) node[midway, above] {RTS (SV\textsubscript{A})};
\draw[-latex, line width=0.5mm, red] (B.155)--(A.25) node[midway, above] {CTS (SV\textsubscript{B})};
\draw[-latex, line width=0.5mm, blue] (A)--(B) node[midway, above] {DATA};
\draw[-latex, line width=0.5mm, red] (B.-155)--(A.-25) node[midway, above] {DATA};
\draw[-latex, line width=0.5mm, blue] (A.-60)--(A.-60-|B.-120) node[midway, above] {ACK};
\end{tikzpicture}
\end{center}
\caption{The version of anti-entropy I implemented}
\end{figurehere} 
\bigskip

The message exchange in the system design was also tweaked. Again, these changes were made to reduce the number of packets sent, and therefore the bandwidth taken up by the anti-entropy process and potential for errors. The design includes DATA FRAME (DF) and DATA packets, where the DF packet sets up the number of expected DATA packets. Instead of sending a separate DF packet, the number of DATA packets expected was set as the first byte of the payload. Each DATA packet is given an ID, its number from the total. When the initiating node (A) has sent all its packets, it waits for the DATA packets sent from the other node as an acknowledgement that all DATA packets have been received. If DATA packets are not seen within the timeout, set in the \verb'config.py' file, the node resends the DATA packets. If this is repeated too many times, again defined in the \verb'config.py' file, the initiating node (A) ceases anti-entropy and enters the listening state again. This prevents A getting stuck in an infinite sending loop if node B stops responding. \\ 
If node A successfully receives all DATA packets from node B, it sends an acknowledgement (ACK) to indicate no resends are necessary and ends the anti-entropy process. \\
When the non-initiating node (B) sees it has received all the DATA packets from node A, and has sent all DATA packets, it waits for the ACK from A. If unseen after a certain time, specified in the \verb'config.py' file, it resends the DATA messages. If an acknowledgement is not seen after a set number of resends, the anti-entropy times out. Figure 3.16 shows a timing diagram for the implemented Epidemic routing.  \\ \\
These variables are configurable to allow users to choose values that work best for their environment. The sensitivity analysis below determined the values I selected when evaluating and using the system.
\begin{figure}[h]
\begin{center}
\tikzset{
    host/.style={rectangle,rounded corners,             
                  thick,draw=black},
    host/.default=black,
    trama/.style={thick,draw=#1,fill=#1, node font = \tiny},
    trama/.default=red,
    ack/.style={trama=blue},
}

\newcommand{\tramaok}[2]{%
    \draw[trama,->, node font = \tiny]  #2 --++(1.5,-2) node[above right,near start] {#1};
}
\newcommand{\tramaperduda}[2]{%
    \path #2 coordinate (a)--++(1.5,-2) coordinate (b) coordinate[midway] (c); 
    \draw[trama,-, node font = \tiny]  (a) --(c) node[below] {#1};
    \draw[trama,-> , node font = \tiny]  (c) -- ++(30:.5);
}

\newcommand{\ackok}[2]{
    \draw[ack,->, node font = \tiny] {#2}--++(1.5,2) node[below right,near start] {#1};
}

\newcommand{\ackperdut}[2]{
    \path #2 coordinate (a)--++(1.5,2) coordinate (b) coordinate[midway] (c); 
    \draw[ack,-]  (a) --(c) node[above] {#1};
    \draw[ack,->]  (c) -- ++(-30:.5);
}

\newcommand{\1}[3]{%
    \draw #1 --++(0,5mm);
    \draw #2 --++(0,5mm);
    \begin{scope}[yshift=2.5mm]
    \draw[-] #1 -- #2 node[above,midway, text = black!50,  node font = \tiny]{#3};
    \end{scope}
}

\newcommand{\4}[3]{%
    \draw #2 --++(0,5mm);
    \begin{scope}[yshift=2.5mm]
    \draw[<-] #1 -- #2 node[below,midway, text = black!50, node font = \tiny]{#3};
    \end{scope}
}


\newcommand{\3}[3]{%
    \draw #2 --++(0,5mm);
    \begin{scope}[yshift=2.5mm]
    \draw[<-] #1 -- #2 node[above,midway, text = black!50, node font = \tiny]{#3};
    \end{scope}
}

\newcommand{\5}[3]{%
    \draw #1 --++(0,5mm);
    \draw #2 --++(0,5mm);
    \begin{scope}[yshift=2.5mm]
    \draw[-] #1 -- #2 node[below,midway, text = black!50, node font = \tiny]{#3};
    \end{scope}}
\newcommand{\6}[3]{%
    \draw #1 --++(0,5mm);
    \begin{scope}[yshift=2.5mm]
    \draw[->] #1 -- #2 node[below, text = black!50,  node font = \tiny]{#3};
    \end{scope}}
\newcommand{\2}[3]{%
    \draw #1 --++(0,5mm);
    \begin{scope}[yshift=2.5mm]
    \draw[->] #1 -- #2 node[above,midway, text = black!50, node font = \tiny]{#3};
    \end{scope}}
\begin{tikzpicture}%[>=stealth]
\draw[help lines,->, node font = \Large, text = black] (-0.2,0) node[host,left] {B}--(13,0);
\draw[help lines,->,  node font = \Large, text = black] (-0.2,2) node[host,left] {A}--(13,2);
\tramaok{HELLO}{(0,2)}
\ackok{RTS}{(1.5,0)}
\tramaok{CTS}{(3,2)}
\ackok{DATA}{(4.5,0)}
\ackok{}{(5,0)}
\ackok{}{(5.5,0)}
\ackok{}{(6,0)}
\tramaok{DATA}{(7.5,2)}
\tramaok{}{(8,2)}
\ackok{ACK}{(9.5,0)}
\3{(0,2)}{(3,2)}{\textbf{Listening State}}
\1{(3,2)}{(6,2)}{\textbf{Received RTS State}}
\1{(6,2)}{(7.5,2)}{\textbf{Get Data State}}
\1{(7.5,2)}{(11,2)}{\textbf{CTS Send Data State}}
\2{(11,2)}{(13,2)}{\textbf{Listening State}}
\4{(0,-0.5)}{(1.5,-0.5)}{\textbf{Listening State}}
\5{(1.5,-0.5)}{(4.5,-0.5)}{\textbf{RTS Anti-Entropy State}}
\5{(4.5,-0.5)}{(9,-0.5)}{\textbf{RTS Send Data State}}
\5{(9,-0.5)}{(12.2,-0.5)}{\textbf{RTS Get Data State}}
\6{(12.2,-0.5)}{(13,-0.5)}{\textbf{Listening State}}
\end{tikzpicture}
\end{center}
\caption{Messages and states of two nodes completing anti-entropy with no missed messages}
\end{figure}
\FloatBarrier

\subsection{Sensitivity Analysis}
The value of each configurable value in the network was determined experientially. The most important of these was how often a HELLO packet would be sent. This has a direct impact on how often anti-entropy would be initiated, and therefore the latency of messages. \\ 
Figure 3.17 shows the latency of 30 messages being sent between two nodes with interference from another node. From this experiment, I decided to send HELLO packets every 5 seconds (with a random jitter). This was a trade-off between potential collisions of HELLO packets, the power consumption involved in sending packets, and the latency of messages passing through the network. The average latency of a message in this analysis when HELLO packets are sent every 5 seconds was 17 seconds. 
\begin{figure}[h]
\begin{center}
\input{sensitivity.pgf}
\end{center}
\caption{The time taken to deliver messages over distance intervals}
\end{figure}
\FloatBarrier

\subsection{Testing}
Testing the Epidemic routing implementation ensured that it worked, particularly with edge cases. The edge cases tested involved: \\
Both nodes contain a full messages dictionary, with 30 messages \\
One node holding some messages and one node with no messages \\
Both nodes have identical messages \\
Both nodes holding no messages \\ \\
This testing highlighted an issue with anti-entropy, where no DATA packets were sent if there were no messages the other node needed. This was a problem as it meant the node would hold the connection open and repeatedly resend messages it believed had not been seen. The issue was rectified by sending one empty DATA packet to indicate that the node had no new messages. \\ \\
Once the edge case testing was finished, I demonstrated the utility of the network by allowing the user to type in a message on the terminal of a laptop on one node. This message was passed through the network to another node and displayed on the attached screen.

\subsection{Pseudocode}
Figure 3.18 shows an abstracted and commented version of the Epidemic routing. Note that logging and error messages have been cut out. The full code is available in the code repository, under \verb'/OnDevice/DeviceCode.py'.
\begin{figure}[h] 
\begin{verbatim}
if state == config.LISTEN:
    args = rfm69.receive()
    # Update the state based on any packets received
    state = handleReceive(args) 

elif state == config.RECEIVED_HELLO:
    # Add the location of the node that sent the HELLO to the obstacles list
    obstacles.append([float(newObstacle[0]), float(newObstacle[1]), 1])
    if sender not in contacted and sender>config.ADDRESS:
        # Anti-entropy initiated by this node
        success, messages = RTSAntiEntropy(dest = sender, messages = messages)
        if success:
            # Add the other node to the dictionary of contacted node 
            # on successful anti-entropy
            contacted.update({sender : config.CONTACTED_LIVES})
    state = config.LISTEN

elif state == config.RECEIVED_RTS:
    # Initiate anti-entropy from the side of sending a CTS       
    success, messages = CTSAntiEntropy(sender, messages, RTSpacket)
    state = config.LISTEN

if state == config.LISTEN and timers.hello():
    # Broadcast HELLO packet
\end{verbatim}
\caption{Abstracted Epidemic routing code}
\end{figure}
\FloatBarrier
\newpage
\section{Medium Access Control}
Medium access control was implemented alongside the Epidemic routing protocol, detailed in \emph{3.6 Epidemic Routing}. If a node overheard the exchange of an RTS / CTS message exchange between two other nodes, it enters a silent state. The node does not broadcast any HELLO or CTS messages, nor respond to RTS messages. The node remains in the silent state until an ACK is seen, sent by the appropriate node matching the exchange of RTS / CTS messages, or until the timer has elapsed, based on a time set in the \verb'config.py' file, currently set to 15 seconds. This timeout was chosen as a worst-case scenario for a very long exchange of messages between two nodes, so even an unusually long exchange will not be interrupted. 

\subsection{Pesudocode}
\begin{figure}[h]
\begin{verbatim}
if packet == CTS:
    state = config.QUIET
    # Record the node that sent the CTS 
    # Allowing us to check if any ACKs overheard are correct 
    sendingCTSNode = sender

if state == config.QUIET:
    args = rfm69.receive()
    # Listen for the ACK connected with the node pair
    # Wait for timeout the timer until 
\end{verbatim}
\caption{Abstracted version of the code for medium access control}
\end{figure}



\section{GPS} 
Before integrating the GPS into the system, I checked that it worked. Several different serial communication protocols were used, starting with SPI. In the end, UART was used as the asynchronicity worked best with the GPS. To ensure that the GPS generated the correct coordinates, I checked that the coordinates given were my location. \\ \\ 
I found that the GPS had a long time to first fix (TTFF) on a cold start. This was because there was no long term memory when power was lost to the device, so any real time clock (RTC) and downloaded almanac data would be lost. A holder for and CR1220 coin cell were added to allow the GPS to keep accurate RTC data when the system was powered off. This significantly reduced the TTFF. Additionally, it allowed the GPS chip to use its built-in EASY assist system, presented in the chip's datasheet \cite{gpsdata}. The EASY assist system allows for faster positioning by calculating up to three days of ephemeris data and saving these predictions. \\ \\
The messages generated by the GPS chip are National Marine Electronics Association (NMEA) 0183 messages, which are then parsed by the system using the \verb'adafruit_gps.py' library. \\


\subsection{Precision}
To test the tracking on the GPS, a short program was written to generate GPX files. A brief walk was tracked with the GPS. For comparison, the same activity was tracked with a smart watch. Figures 3.4 and 3.5 show the GPX files overlaid on Google Maps. \\
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{gps1.jpg}
\end{center}
\caption{The first attempt at tracking a walk with GPS. The red line is the GPX track generated by the board, the blue line is the GPX track generated by a smartwatch \cite{googlemapsgeneral}}
\end{figure}\\ 
As can be seen from Figure 3.4, the track first generated by the system's GPS was jagged and inaccurate. On examination of the GPS coordinates generated by the board, they are only precise to five significant figures, so it is unsurprising that the coordinates are not precisely accurate. Therefore, the degrees and minutes were combined to generate more precise coordinates, to eight significant figures. Figure 3.5 shows the GPX track with the more accurate coordinates. Based on the route taken when walking, the board's GPX track is slightly more accurate than the smartwatch's. 
\begin{figure} [h]
\begin{center}
\includegraphics[scale=0.4]{gps2.jpg}
\end{center}
\caption{The final attempt at tracking a walk with GPS. The red line is the GPX track generated by the board, the blue line is the GPX track generated by a smartwatch \cite{googlemapsgeneral}}
\end{figure}
\FloatBarrier

\subsection{Haversine Formula}
The haversine formula was used to calculate the distance between two sets of GPS coordinates. This was chosen as it is relatively simple to compute. The haversine formula is very commonly used to calculate distance between GPS coordinates \cite{haversine}. It is notable that this formula finds two points on a sphere, and the earth is an ellipsoid and the radius of the earth is not consistent across the globe. The average radius of the earth was used instead. As this is an approximation, it will result in errors of up to 0.5\% \cite{haversine}. The distances being measured are relatively small, so this was not a problem. \\
Vincenty's formulae takes the ellipsoidal nature of the earth into consideration, but is more complicated and due to the small distances involved it was decided that the saving made on compute time would be more beneficial than the additional accuracy in distance measurements. \\
\subsubsection{Equations}
The haversine is defined: \\
$haversine(\theta) = sin^2(\theta/2)$ \\ \\ 
Where $\phi$ is latitude and $\lambda$ represents longitude and $haversine(\theta)$ is abbreviated to $hav(\theta)$. \\
$hav(\theta) = hav(\phi_2 - \phi_1) + cos(\phi_1) cos(\phi_2) hav(\lambda_2 - \lambda_1)$ \\
$\theta$ is the angle between the two points on the sphere. $d$ is the distance between the points and $r$ is the radius of the sphere. \\
$\theta = d / r$ \\ \\ 
Combining these equations gives us the distance between the two points as \\
$d = r * 2 * sin^{-1}(\sqrt{sin((\phi_2 - \phi_1)/2))^2 + cos(\lambda_1) * cos(\lambda_2) * sin((\lambda_2 - \lambda_1)/2))^2})$

\subsection{Satellite Error}
It was found that the GPS location moved even when the board was stationary. I believed this to be an error in the library, perhaps related to the precision of floating point numbers. However, research indicated that this was due to noise at the receiver causing the GPS location to move around. This noise was due to the clock phase noise and interpolation of ephemeris data \cite{satellite}. Implementing a Gaussian or Kalman filter to remove some of the noise would be possible and is further work. Another solution to this problem is demonstrated by the telemetry in the Boat Race, where an external antenna is used and GPS readings are compared to the values from a base station that has been previously gathering data.  %In the meantime it is necessary to accept a small quantity of error in the reading. %After attempting to debug this and talking to the gentleman who took GPS measurements for the Oxford Cambridge Boat Race, I discovered that this is a limitation of the technology, and that as satellites move across the sky they generate noise in the readings. In their solution to this problem, the Boat Race sets their own base station up at the end of the course, uses an external antenna and a  reads from the GPS up to 20 times a second. They then feed this data through a Kalman filter to give the final value for location. Implementing a Gaussian or Kalman filter to remove some of the noise from the GPS would be possible in this system and is further work. In the meantime it is necessary to accept a small quantity of error in the reading. 
 
 
\section{MicroPython}
The libraries to allow a rudimentary interface with the RFM69 and GPS boards were both written in CircuitPython. I opted to use these libraries to interface with this hardware rather than write my own libraries. \\ 
MicroPython supports both multithreading and interrupts, neither of which CircuitPython supports. It was therefore preferred to use MicroPython to implement the core of the system, particularly so the application and networking threads could run concurrently, maximally utilising the two cores in the Raspberry Pi Pico \cite{rp2040}. I ensured the Raspberry Pi Pico could run two threads by defining two functions that calculate the Fibonacci sequence using two global variables and a lock to ensure concurrency control. This code successfully calculated the Fibonacci sequence when I allocated a thread to each core. \\ \\ 
CircuitPython has an associated library, Blinka \cite{blinka}, that should emulate the CircuitPython API, allowing CircuitPython software to work with MicroPython. However, when attempting to run a simple sending packet and receiving packet setup, I found the code did not work. To debug this problem, I ran two nodes trying to send messages to each other one running CircuitPython and one running MicroPython with the Blinka libraries. A third node read any packets that were sent and logged them. The MicroPython node continued not to receive or send any data. I lowered the baud rate in case the Blinka or SPI interfaces were being overwhelmed. Even with a dramatic reduction, no change was found. \\
This was when my supervisor kindly lent me his expertise and logic analyser. We found that the Pico was sending data to the RFM69. However, it was sending all communication twice, so the RFM69 did not respond. \\ \\
Rather than trawl through the Blinka library looking for the bugs that caused this, we decided instead to use CircuitPython for the whole system. This meant the two state machines had to be redesigned to run on only one core. Changing to CircuitPython allowed project time to be spent working on the system, rather than searching for a bug. 


\section{User Interface}
\subsection{Hardware Choice}
In order for the MANET and GPS to be useful, a rudimentary user interface was built. This initially contained only a buzzer and button. An LED was added to allow the device to be more accessible to those who cannot hear the buzzer. \\
Therefore, a button with a built-in LED was chosen.  The chosen button was also waterproof, momentary, non-locking, and relatively large. These characteristics were chosen to keep the design of a node simple, easy to construct, and less likely to get moisture inside the box, as the system will get wet in rowing boats. They also allowed the user to effortlessly press the button when they encounter an obstacle. \\
A 2k$\Omega$ resistor was used in series with the buzzer to modulate the tone. A brief survey of rowers indicated the tone generated by a 2k$\Omega$ resistor to be most suitable as a warning. 

\subsection{Integration}
The buzzer and LED were wired in parallel to the same pin in the Pico, to allow the flashing and buzzing to occur simultaneously. This is shown in the wiring diagram under the Final System section. If the system detected that the current GPS position of the node was within the distance specified by the \verb'GPS_DISTANCE' value in \verb'config.py', using the haversine formula. \\ \\ 
As CircuitPython does not allow interrupts, the value of the button was polled. If the value was true, the button was pressed. The value was polled again after 0.5 seconds. If the value was still true, this was considered to be a `long' press, meaning the obstacle that had been detected should be marked as urgent and propagated through the network at an accelerated rate. \\ \\
With the user interface integrated, the third success criterion, \emph{`An application layer had been implemented to allow utility of the network'}, was achieved. 

\subsection{Testing}
The testing of the user interface first made sure each piece of hardware worked. I wrote a short program to flash the LED and sound the buzzer when the button was pressed. \\
The next stage of testing ensured the system generated new obstacles, adding them to the message buffer, when the button was pressed. This was done by generating messages and checking that these messages were received by nearby nodes.  \\ \\
A surprising issue occurred when a node was powered from a power bank, where the node would shut down in a non-deterministic fashion. After experimenting with other power packs and powering the node from mains power, I decided that the power bank probably had an automatic shutoff if a certain level of current was drawn from the power pack as a safety feature. This was rectified by using a different power bank, although batteries could have been used.  
\pagebreak
\section{Repository Overview}
\renewcommand*\DTstylecomment{\fontfamily{cmss}\selectfont}
\dirtree{%
.1 .
.2 LICENCE.
.2 README.md.
.2 OnDevice.
.3 boot.py.
.3 lib. 
.3 {\footnotesize \fontfamily{cmss}\selectfont This is the final product, the code that should be uploaded to the Raspberry Pi Pico. The boot.py file contains the implementation of the system to help avoid collisions. The lib file contains \texttt{adafruit\_gps.py}, a library I did not write but use, licenced under the MIT licence. \texttt{rfm69.py} is a modified version of \texttt{adafruit\_rfm69.py}, which I have modified to include fixed length packets and fixed some bugs, so it is a combination of code I wrote and others' code. \\}.
.2 Development.
.3 Application.
.3 MACEpidemic.
.3 Misc.
.3 {\footnotesize \fontfamily{cmss}\selectfont Contains code used in the development of the system. \texttt{MACEpidemic} and \texttt{Application} contain the code generated when building the MANET and interface to it respectively. \texttt{Misc} contains a more varied set of files, generated when testing out hardware and other components of the system. \\ }.
.2 Evaluation.
.3 Bandwidth.
.3 FourNodes.
.3 Latency.
.3 OnWater.
.3 Partition.
.3 {\footnotesize \fontfamily{cmss}\selectfont Contains various folders depending on the evaluation being conducted. Each folder contains the code used to run that subsection of the evaluation, CSV files of results, and Python code for analysis of the results. \\}.
}

%%% EVALUATION %%%
\newchapter{4}{Evaluation}
\setcounter{figure}{0}
The goal of the evaluation was to prove correctness and utility. The evaluation also allows comparison between the MANET and other implementations of Epidemic routing, using common benchmarks. \\
The majority of the evaluation was conducted according to the plan in Appendix B [\hyperref[appendixB]{Appendix B}]. Evaluation was split into a performance evaluation of the MANET, and an evaluation of the whole system, including a qualitative evaluation. \\
The key metrics evaluated in the MANET were percentage of packets delivered, latency, bandwidth and time taken to propagate messages after partition. \\
The whole system evaluation considered the GPS readings taken by the system and its interaction with the user.\\ 

\section{Evaluating the MANET}
The evaluation of the MANET was designed to mirror the evaluation performed by Vahdat and Becker's paper \cite{epidemic}. The key difference between the implementations was my project being implemented in hardware, while theirs was simulated. The similarities between the evaluations allowed me to prove correctness through comparison of results. It also offers insight into both implementations and any improvements that could be made. \\

\subsection{Latency}
The latency of a message is the time between the message being generated at node A and received at node B. \\
Node B started next to node A and was moved further away, finishing at a maximum distance of 500 metres. There was a third node, C, interacting with the \{A, B\} pair. This allowed messages to pass over a distance greater than the radio range. The distances (denoted d) between nodes A and B were 0, 10, 100, 250 and 500 metres. 60 messages were generated by A at each distance. Figure 4.1 shows the setup, with radio connections between nodes marked in blue and the distance measured in grey. 
\begin{figurehere}
\begin{center}
\begin{tikzpicture}[a/.style={circle, draw=black, very thick, minimum size=17mm},]
\node[a]      (maintopic)                              {\Huge A};
\node[a]        (uppercircle)       [right =3cm  of maintopic] {\Huge B};
\node[a]        (c)       [above=0.5 cm  of uppercircle] {\Huge C};
\draw[line width=0.5mm, blue] (maintopic) -- (uppercircle);
\draw[line width=0.5mm, blue] (maintopic) -- (c);
\draw[line width=0.5mm, blue] (uppercircle) -- (c);
\begin{scope}
\draw[black!50] (maintopic.-10) -- (uppercircle.-170)  node[below,midway, text = black!50]{d};
\end{scope}
\end{tikzpicture} \\
\begin{tikzpicture}[
a/.style={circle, draw=black, very thick, minimum size=17mm},]
\node[a]      (maintopic)        {\Huge A};
\node[a]        (morenode)       [right =3cm  of maintopic] {\Huge C};
\node[a]        (uppercircle)       [right =3cm  of morenode] {\Huge B};
\draw[line width=0.5mm, blue] (maintopic) -- (morenode);
\draw[line width=0.5mm, blue] (morenode) -- (uppercircle);
\draw[black!50] (maintopic.-10) -- (morenode.-170)  node[below,midway, text = black!50]{d};
\draw[black!50] (maintopic.-10) -- (uppercircle.-170); 
\end{tikzpicture}
\end{center}
\caption{The network used for latency testing}
\end{figurehere}
\FloatBarrier
\bigskip
The results of the latency evaluation are shown below. Figure 4.2 shows the percentage of packets delivered over time. Figure 4.3 breaks down the data behind this, showing the times that each packet arrived. Table 4.1 shows the raw data. The metrics for 0 and 10 metres differ little, with an average delivery time of 15.0 and 15.7 seconds respectively. The 100 metre interval follows a similar pattern. There is a significant drop-off when the distance is increased to 250 and 500 metres, as more than one hop is needed to transmit messages from A to B. There is an increase in the standard deviation, due to the increased variability from passing messages over multiple nodes. As distance increases, the latency increases. This is likely due to spreading of the signal causing more errors in transmission. \\
At first glance, these latencies seem unusually high. However, when compared to the latencies in Vahdat and Becker's paper, we see their latencies are also high \cite{epidemic}. This is due to the design of Epidemic routing. Epidemic routing is delay tolerant, optimised to transmit messages through networks with a high chance of partition, rather than optimised for latency. A message is not sent as soon as it is generated. Instead, neighbouring nodes periodically poll each other to find any messages that are not on both nodes. This polling also explains the increased variability in delivery times when more than one hop is taken, as the anti-entropy process needs to occur multiple times to allow a message to reach its destination.
\begin{figure}[h]
\begin{center}
\input{percentages.pgf}
\end{center}
\caption{The percentage of packets delivered with time}
\end{figure}

\begin{figure}[h]
\begin{center}
\input{distanceIntervals.pgf}
\end{center}
\caption{The time taken to deliver messages over distance intervals. The dark blue line represents the average, the cyan dots represent individual datapoints}
\end{figure}
\begin{table}[h]
\begin{center}
\resizebox{\textwidth}{!}{\begin{tabular}{ |r|r|r|r|r| } 
\hline
Distance & Average Latency & Standard Deviation & Minimum Latency & Maximum Latency \\ 
/Metres & /Seconds & /Seconds & /Seconds & /Seconds\\ 
\hline
0 & 15.045 & 13.796 & 1 & 57\\ 
\hline
10 & 15.703 & 16.199 & 3 & 92 \\ 
\hline
100 & 34.914 & 37.966 & 2 & 137 \\ 
\hline
250 & 151.741 & 126.721 & 12 & 399 \\ 
\hline
500 & 233.357 & 138.679 & 20 & 494 \\ 
\hline
\end{tabular}}
\end{center}
\caption{Packet latency}
\end{table} 
\FloatBarrier

\subsection{Bandwidth}
Evaluating the bandwidth of the system was done to work out how many messages the MANET can transfer. In reality, it is unlikely the MANET will need to process as many messages as sent in this test as obstacles will not be generated this quickly by human users. Bandwidth testing was conducted between two nodes, with one node generating messages at a set rate and broadcasting them to the other node. The rate at which messages were generated was increased, up to 10 messages being generated each second. Figure 4.4 shows the setup for this test. \\ \\
As shown in Figure 4.5, the MANET has a relatively low bandwidth. The bandwidth plateaued at around 0.4 messages transferred each second, equivalent to taking around 3 seconds to pass a message between two nodes. To improve the bandwidth of the system, the time between discovery (HELLO) packets sent by each node could be decreased. 
\begin{figurehere}
\begin{center}
\begin{tikzpicture}[
node/.style={circle, draw=black, very thick, minimum size=17mm},
]
%Nodes
\node[node]      (maintopic)  {\Huge A};
\node[node]        (uppercircle)   [right =3cm  of maintopic] {\Huge B};
%Lines
\draw[line width=0.5mm, blue] (maintopic) -- (uppercircle);
\end{tikzpicture} 
\end{center}
\caption{The network used for bandwidth testing}
\end{figurehere}
\begin{figure}[h]
\begin{center}
\input{bandwidth.pgf}
\end{center}
\caption{The bandwidth of a fully connected two node network with an increasing number of messages generated each second}
\end{figure}
\newpage

\subsection{Percentage of Packets Delivered}
With the exception of the bandwidth evaluation, where more packets were generated than could be delivered, 100\% of packets were delivered throughout the evaluation. This mirrors the results found by Vahdat and Becker, where their simulation had a 100\% delivery rate when the number of messages was smaller or equal to the size of the message buffer \cite{epidemic}.\\

\subsection{Partitions}
The network was broken into smaller networks to ensure that messages are propagated through the network after partition and compare the time taken to propagate messages after partition. \\
Partition evaluation was conducted with four nodes. The experiments used two pairs. Each pair was set up to communicate with each other, then brought into range of the other pair. Figures 4.6 and 4.7 show the starting and finishing states of the network. 
\begin{figurehere}
\begin{center}
\begin{tikzpicture}[
a/.style={circle, draw=black, very thick, minimum size=17mm},
]
\node[a] (aa) {\Huge A};
\node[a] (bb) [below=2cm of aa] {\Huge B};
\node[a] (cc) [right=5cm of aa] {\Huge C};
\node[a] (dd) [right=5cm of bb] {\Huge D};
\draw[line width=0.5mm, blue] (aa) -- (bb);
\draw[line width=0.5mm, blue] (cc) -- (dd);
\end{tikzpicture}  \\
\end{center}
\caption{The network at the start of partition testing}
\end{figurehere}
\FloatBarrier
\begin{figurehere}
\begin{center}
\begin{tikzpicture}[
a/.style={circle, draw=black, very thick, minimum size=17mm},
b/.style={circle, draw=black, very thick, minimum size=17mm},
c/.style={circle, draw=black, very thick, minimum size=17mm},
d/.style={circle, draw=black, very thick, minimum size=17mm},
]
%Nodes
\node[a] (aa) {\Huge A};
\node[b] (bb) [below=2cm of aa] {\Huge B};
\node[c] (cc) [right=2cm of aa] {\Huge C};
\node[d] (dd) [right=2cm of bb] {\Huge D};

%Lines
\draw[line width=0.5mm, blue] (aa) -- (bb);
\draw[line width=0.5mm, blue] (aa) -- (cc);
\draw[line width=0.5mm, blue] (aa) -- (dd);
\draw[line width=0.5mm, blue] (bb) -- (dd);
\draw[line width=0.5mm, blue] (bb) -- (cc);
\draw[line width=0.5mm, blue] (cc) -- (dd);
\end{tikzpicture} 
\end{center}
\caption{The network at the end of partition testing}
\end{figurehere}
\FloatBarrier

\subsubsection{Asymmetric}
Asymmetric partition testing consisted of the \{A, B\} pair holding 30 messages before partition. After the partition was removed, the \{C, D\} pair held the same messages \{A, B\} held. Over 2 partitions, the average time taken for all nodes in the network to hold the same messages was 106.5 seconds. Given an overestimate for the speed of a rowing boat as 15km/h, and the radio range of 500 metres, this would allow two boats to be in range for 120 seconds, enough time for the maximum number of messages to be transferred between two boats.  \\ \\
\begin{table}[h]
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Run & Time for Node C /Seconds & Time for Node D /Seconds \\ 
\hline
1 & 50 & 135 \\ 
\hline
2 & 78 & 44  \\ 
\hline
\end{tabular}
\end{center}
\caption{Time taken for all messages to be received in asymmetric partitions}
\end{table}  
\FloatBarrier 

\subsubsection{Symmetric}
Symmetric evaluation of the network gave the two pairs of nodes different sets of messages.
The average time for nodes to receive all 30 messages was 130 seconds, 23.5 seconds greater than an asymmetric partition. This is due to the anti-entropy process having to occur in both directions, as both nodes involved in the message exchange hold messages the other nodes have not seen. 
\begin{table}[h]
\begin{center}
\begin{tabular}{ |c|r| } 
\hline
Node & Time for messages to be received /Seconds\\ 
\hline
A & 87 \\
\hline
B & 159 \\
\hline
C & 145 \\
\hline
D & 129 \\ 
\hline
\end{tabular}
\end{center}
\caption{Time taken in seconds for all messages to be received in symmetric partitions}
\end{table}  
\FloatBarrier

\subsection{Four Node Field Evaluation}
This part of the evaluation was conducted as is as close to the use case as can be conducted on land. This evaluation is also most similar to the evaluation conducted by Vahdat and Becker \cite{epidemic}. The percentage of packets delivered is best illustrated in the evaluation with four nodes. To run this test, I recruited four volunteers to move around a large field, approximately 500 x 500 metre area. This allowed nodes to move in and out of range of each other. Each node had a 0.1 probability of generating a message each second, with 30 messages generated. The transmission range of the nodes was reduced to 30m. The nodes moved around this area for approximately 15 minutes. This test was run twice, with results being compared to ensure no anomalies occurred. \\ \\
This part of the evaluation is a reduced version of the evaluation performed in Vahdat and Becker's paper \cite{epidemic}, where 50 nodes were simulated within a 1500 x 300 metre area. Unfortunately, Vahdat and Becker do not release the implementation details for their paper, so a direct comparison of the two implementations is not available. However, we can compare our results to their results and draw conclusions from this. The coverage floor for both evaluations is calculated as $\pi * r^2 / a$ where $a$ is the total testing area (metres\textsuperscript{2}) and $r$ is the transmission range of the radios (metres).  \\ 
The results of the five node evaluation fit with the trend shown in Vahdat and Becker's evaluation. Table 4.4 shows the results I obtained in my evaluation and the results Vahdat and Becker obtained \cite{epidemic}. The coverage floor I used did not exactly match any of the values in their evaluation, so the surrounding two coverage floors are shown. The coverage floor and latency have an inverse relationship, best described by a reciprocal function. The average and maximum latency found in my evaluation fit this trend. However, the maximum latency in my evaluation is much higher than that is Vahdat and Becker's evaluation. This could be due to the hardware used in the evaluation, or could simply be a result of one node being out of range of other nodes for a prolonged period of time.\\ \\
Figure 4.8 shows the latency of the four nodes with the average trend in black. The fourth node, in cyan, seems to be an outlier. The differences between the lines are likely due to the non-random nature of the humans walking in the test area, and any deviations in the hardware I set up. This part of the evaluation could be expanded by using more nodes and a more random path for each node. 
\begin{table}[h]
\begin{center}
\resizebox{\textwidth}{!}{\begin{tabular}{ |c|r|r|r|r| } 
\hline
Evaluation & Delivery rate /\% & Average Latency /Seconds & Max Latency /Seconds & Coverage Floor /\% \\ 
\hline
Part II Project & 100 & 69.287 & 347 & 1.13\\
\hline
Vahdat and Becker  & 100 & 12.8 & 177 & 1.75\\
\hline
Vahdat and Becker & 100 & 153.0 & 760 & 0.44\\
\hline
\end{tabular}}
\end{center}
\caption{Results from the four node evaluation and comparison to other papers}
\end{table}  

\begin{figure}[h]
\begin{center}
\input{fiveNodes.pgf}
\end{center}
\caption{The latency of packets in the four node evaluation}
\end{figure}

\section{Evaluating the Crash Prevention System}
The system works. When used on rowing boats, it notified rowers of other boats who are using the system and of registered obstacles. The water evaluation was completed in coxless single person boats. This section of the evaluation ensured that I fulfilled the third success criteria, \emph{an application layer has been implemented to allow utility of the network}. The water evaluation was conducted last due to the increased risk of the project becoming water damaged or falling into the river. \\ 

\subsection{GPS}
Rivers and lakes are in many ways ideal for the GPS, being large open spaces with few obstacles blocking the system's view of the sky. However, I was concerned that bridges or similar obstructions would interfere with the GPS tracking on each boat. This was of particular concern as a bridge could also be an obstacle. The GPS tracking on water was examined by logging the location at regular intervals in a GPX file. \\
Figure 4.7 shows the GPS trace underneath a bridge. While the error caused by the bridge is minimal, it could be improved by applying a Gaussian or Kalman filter, as done in other GPS tracking for rowing boats. An issue this experiment inadvertently highlighted is that the trace does not appear to be accurate, showing the boat moving along the ground at some points. When comparing this to the GPS points taken in later experiments, this does not seem to be a systematic error, but rather a random error in the placement of the GPS during that outing. This suggests an obstacle may be recorded in the wrong place due to an inaccurate GPS reading.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{bridgeGPS.jpg}
\end{center}
\caption{The GPS track taken by a node, shown on Google Maps \cite{googlemapsgeneral}}
\end{figure}

\subsection{Crash Prevention on Water}
\subsubsection{Notification of Other Rowing Boats}
To ensure the system worked in the use case environment, I went rowing with a volunteer, each of us with a device on our boat. We ensured that the boats were notified when they were approaching each other. We found this notification to come at around 10 metres between boats. However, when the boats are rowing alongside one another, with no chance of collision, they continually alert the user to the other boat. This was fixed by giving each obstacle a unique ID and only notifying the user of a particular obstacle if they have not been notified of this obstacle in the last 3 minutes. While this does not eliminate the problem, it significantly reduces it and ensures users are still notified of an obstacle they go past twice. \\
\subsubsection{Propagation and Notification of Obstacles}
The nodes transferred knowledge of obstacles between them. To test this, one boat went further up the river and registered a `new obstacle' at a pre-agreed point (shown in Figure 4.8, opposite the Goldie Boat House) by pressing the button on the device. The first boat then returned to the second, which moved towards the potential obstacle. This gave a time delay between the boats approaching the obstacle, showing that messages are propagated through the network to warn other boats of the obstacles. The node warned the other boat of the obstacle. 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{obstacle.jpg}
\end{center}
\caption{The registered obstacle as a red marker on Google Maps \cite{googlemapsgeneral}}
\end{figure}

\subsection{User Evaluation}
To evaluate how useful the system was to the users, I interviewed the rower in the other single. While their overall impression was positive, the survey highlighted extra work that needed to be done to the user interface. They pointed out that the buzzer, even with the bug notifying users about boats they are rowing alongside fixed, might be a violation of noise rules at certain times. Additionally, the box had to be unscrewed to plug in or unplug the power pack, turning each node on and off. These could be fixed by including another button to turn off the buzzer, notifying users only through the LED and a switch external to the node to turn it on and off. \\

\subsection{Limitations from the Implementation}
There are some limitations to the system due to its design. The packet format means there can be at most 255 nodes in the system, as two bytes are reserved for the node address and address 0 is reserved for broadcast. The number of obstacles stored in memory is limited by the available memory on the chip, 1.9MB as 1MB is dedicated to the code running the node. As the obstacle size is 10 bytes, 95000 obstacles can be stored on a device, which is sufficient. However, the message buffer is limited to 30. This limit on the message buffer is there to allow the unique ID for each message to fit into a single 64 byte packet, but means that the maximum number of obstacles a node can pass to a neighbour is 30.

%%% CONCLUSION %%%
\newchapter{5}{Conclusion}
\setcounter{figure}{0}
\section{Achievements}
In the introduction, I highlighted the issues around crashes in rowing boats and the need for a system to help prevent such crashes. This dissertation has presented such a system, propagating knowledge about obstacles through a network of rowing boats using the Epidemic routing protocol. Users are notified by a buzzer and an LED when they approach an obstacle and can add obstacles they are unfortunate enough to discover. Figure 5.1 shows a node from the final product, a box attached to a single scull. \\ \\
Three success criteria were laid out as part of the preparation: \\ 
{\begin{tabular}{ll}
The Epidemic routing protocol is implemented within the network\\
An evaluation of the network has been carried out\\
An application layer has been implemented to allow utility of the network \\
\end{tabular} \\ \\
This project has met and exceeded the success criteria. Amongst the extension criteria achieved, medium access control was implemented, high and low priority messaging was defined within Epidemic routing, and a review of the application layer was conducted. \\ \\
As part of this project, I have contributed to open source libraries and furthered my knowledge of microcontrollers, GPS and networking. 

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.13]{boxOnBoat.jpeg}
\end{center}
\caption{The final product in use, attached to the canvas of a rowing boat}
\end{figure}
\FloatBarrier

\section{Reflections}
There were upsides and downsides to implementing the project in hardware. It taught me huge amounts about serial communication protocols and other low level implementation details. It also allowed for a more holistic approach to the evaluation, using the system on rowing boats. However, it is undeniable that the hardware made some aspects of the project more difficult, particularly when it came to debugging a problem. For instance, I soldered an antenna to a radio module in such a way that caused errors in the received packets, a problem I did not diagnose until I swapped the module for another one. Issues like this were commonplace, particularly as the nodes were still being researched and developed when I was using them, so they were not as robust as I would have liked. \\
An aspect that went well was the choice of hardware. The availability of widely tested libraries for that hardware that I could modify gave me a level of flexibility in the low level aspects, but allowed me to delegate some of the boilerplate coding. \\ \\
The preparation chapter lays out the choices I made with respect to the software development methodology, tools and programming language. These choices were all found to be effective in designing and building the system. It was particularly helpful to have a plan that split the project into stages with defined deliverables at each stage. \\ \\ 
While the research phase was designed to cover broad parts of the area in order to find the best solution to a problem, I spent too much time researching various potential routing protocols. With the benefit of hindsight, it would have been beneficial to settle on the Epidemic routing protocol earlier in the process. \\

\subsection{Other Approaches}
There have been other approaches to this problem. ROWCUS used radar to attempt to solve this problem. This technological approach has the benefit that no person has to mark the location of an obstacle to be warned of it but is likely to miss some obstacles, particularly those submerged underneath the water, arguably the most dangerous obstacles as the users cannot see them. ROWCUS has ``decided not to pursue'' their system any further. \\

\section{Future Work}
There is future work that could be conducted in relation to both the networking and application components of the project. \\ \\
There are many parameters in the \verb'config.py' file that impact routing. These could be tweaked to optimise communication over water. The experiments to determine the values for these parameters were performed indoors rather than on water (the use case) as it was not pragmatic to perform these experiments on the water.
The MANET could be further improved by integrating ideas from routing protocols other than Epidemic. For instance, as in GPSR, the GPS location could be used, either by only contacting nearby nodes to increase the probability that an anti-entropy session is successful. The location could also be used to prioritise sending messages about new obstacles to nodes that are near these obstacles.  A metric for transmission quality, in radio communication the received strength signal indicator (RSSI), could influence if an anti-entropy session should be initiated. \\ \\ 
The application component could be further improved by taking the direction of the rowing boat into account when notifying the user of an obstacle. The GPS could be further improved by applying a Gaussian or Kalman filter to reduce the noise in the location, particularly under bridges. Additional improvements could be made from the suggestions of users, such as a switch to mute the buzzer. \\

\section{Other applications}
Such a system could be utilised for other applications. The most obvious is collision avoidance for other water sports, such as canoeing and kayaking. There are more avant-garde applications for this system. Deciding if boats have collided within competitions, removing human bias, is one of these potential applications. The low latency may be a concern in other uses of the system. The latency needs to be comparable to the speeds achieved by the nodes in the MANET to allow messages to propagate through the system.

%%% BIBLIOGRAPHY  %%%
% TODO -- why has this kille any capitalization in
% the names of the references? E.g. DARPA
\bibliographystyle{IEEEtran}
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{refs}


%%% APPENDICES %%%
\chapter*{Appendices}
\addcontentsline{toc}{chapter}{Appendices}  

\section*{A -- Guide to Building a Node}
\label{appendixA}
\addcontentsline{toc}{section}{A -- Guide to Building a Node}  
\setcounter{chapter}{0}
\setcounter{figure}{0}
\input{README}

\newpage
\section*{B -- Evaluation Plan}
\label{appendixB}
\addcontentsline{toc}{section}{B -- Evaluation Plan}  
\setcounter{figure}{0}
\input{evaluationPlan}

%\newpage
%\section*{C -- Progress Report}
%\label{appendixC}
%\addcontentsline{toc}{section}{C -- Progress Report}  
%\setcounter{figure}{0}
%\input{progressReport}

\newpage
\section*{C -- Project Proposal}
\label{appendixC}
\addcontentsline{toc}{section}{C -- Project Proposal}  
\setcounter{figure}{0}
\input{phase3}

\end{document} 