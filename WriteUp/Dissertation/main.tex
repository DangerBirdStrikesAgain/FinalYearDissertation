% Template for a Computer Science Tripos Part II project dissertation
\documentclass[12pt,a4paper]{report}
% Gives a better chapter
\newcommand{\newchapter}[2]{
    \setcounter{chapter}{#1}
    \setcounter{section}{0}
    \chapter*{#2}
    \addcontentsline{toc}{chapter}{#1 #2}
}

\usepackage{titlesec}

\titleclass{\subsubsubsection}{straight}[\subsection]

\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}

\titleformat{\subsubsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
  {3.25ex \@plus1ex \@minus.2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
  {3.25ex \@plus1ex \@minus .2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@paragraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\makeatletter
\newenvironment{figurehere}
  {\def\@captype{figure}}
  {}
\makeatother
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage{verbatim}
\usepackage[utf8]{inputenc}
\usepackage{caption}
\usepackage{placeins}
\captionsetup{justification=raggedright,singlelinecheck=false}
\usepackage[none]{hyphenat}
\usepackage{graphicx}				% Allows for photos to be added
%\usepackage{parskip} 				% Stops the horrific spacing 
\usepackage[top=0cm, foot=1.5em, bottom=2.5cm, left=2cm, right=2cm]{geometry} 	% Set margins to .5 inches 
\addtolength{\topmargin}{0.5in}		% Set top margin to 1 inch
\usepackage{hyperref}				% Hyperlinks package
\hypersetup{colorlinks=true, linkcolor=blue, citecolor = blue, filecolor=black, urlcolor=blue} 	% Make types of hyperlinks
\urlstyle{same}
\usepackage[none]{hyphenat}			% Stops it splitting words over two lines 

\renewcommand*\familydefault{\sfdefault} 
\usepackage{setspace}
\setstretch{1}
\usepackage{docmute}
\usepackage{tikz}
\usetikzlibrary{matrix,chains,positioning,decorations.pathreplacing,arrows, automata}

%\graphicspath{}			if you have trouble getting images in the thing, asks for graphics in the same folder
%\usepackage{hhline}         			% Horizontal lines in tables
\usepackage{siunitx}        			% Correct spacing of units
\usepackage{amsmath}        			% American Mathematical Society
\usepackage{amssymb}        			% Maths symbols
%\usepackage{amsthm}         			% Theorems
 \usepackage{lastpage}      			% ``n of m'' page numbering
%\usepackage{mathtools}
%\usepackage{changepage}
%\usepackage{blindtext}

\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\setlength{\parindent}{0pt} % get to fuck the paragraph indent
\begin{document}

%%% TITLE PAGE %%%
\thispagestyle{empty}

\rightline{\LARGE Alexandra Riddell-Webster}

\vspace*{60mm}
\begin{center}
\Huge
\textbf{A System to Help Prevent Crashes in Rowing Boats} \\[5mm]
Computer Science Tripos -- Part II \\[5mm]
Murray Edwards College \\[5mm]
2023
\end{center}

%%% DECELERATION OF ORIGINALITY %%%
\pagestyle{plain}
\chapter*{Declaration of Originality}

I, Alexandra Riddell-Webster of Murray Edwards College, being a candidate for Part II of the Computer Science Tripos, hereby declare that this dissertation and the work described in it are my own work, unaided except as may be specified below, and that the dissertation does not contain material that has already been used to any substantial extent for a comparable purpose. In preparation of this dissertation I did not use text from AI-assisted platforms generating natural language answers to user queries, including but not limited to ChatGPT.\\ \\
I am content for my dissertation to be made available to the students and staff of the University. \\

\bigskip
\leftline{\textbf{Signed} }
\includegraphics[scale=0.35]{sig.jpg} \\
\leftline{\textbf{Date}} \\ 
\today

%%% ACKNOWLEDGEMENTS %%%
\chapter*{Acknowledgements}
This dissertation owes a huge amount to Matthew Ireland, for supervising me. My UTO, Jon Crowcroft was invaluable. Thanks to Cambridge University Boat Club, in particular Patrick Ryan, Mike Taylor and Rosa Millard, for allowing me to put strange boxes on boats, advising me on communication over water and helping me evaluate the system. I also thank Duncan Barnes for discussing GPS and electronics on rowing boats with me.


%%% PROFORMA %%%
\chapter*{Proforma}

{\large
\begin{tabular}{ll}
\bf Candidate Number:   & 23487C \\
\bf Project Title:  & A System to Help Prevent \\
& Crashes in Rowing Boats \\
\bf Examination:  & Computer Science Tripos -- Part II, May 2023      \\
\bf Word Count:    & TODO \\ % \footnotemark[1]   \\
\bf Code Line Count:    & TODO \\ % (yes, inc. comments) Code line count: Number of lines of code written by the student in the final version of their software. (say how this was calculated)\\
\bf Project Originator: & The Candidate     \\
\bf Supervisor:         & Mr Matthew Ireland  \\ 
\bf University Teaching Officer:  & Prof. Jon Crowcroft \\ 
\end{tabular}
}
%\footnotetext[1]{TODO} This word count was computed by \texttt{detex diss.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w} }
%\stepcounter{footnote}


\section*{Original Aims of the Project}
The objective of this project was to design a system to help prevent crashes in rowing boats. The goal of this system was to warn rowers and coxes when they approach obstacles, be they other boats or items in the river. This project also aimed to evaluate such a system.

\section*{Work Completed}
All core success criteria of were met and some extension criteria implemented. \\ 
This project created such a system to help prevent crashes in rowing boats. Knowledge about obstacles were propagated through a mobile ad hoc network (MANET) of rowing boats using the Epidemic routing protocol. Users were warned when approaching a known obstacle by means of a buzzer and LED light. The MANET and system were thoroughly evaluated. \\
The whole system was documented and will be available, open source, after my graduation. \\ 
\section*{Special Difficulties}
None.

%%% CONTENTS %%%
{
\hypersetup{linkcolor=black}
\tableofcontents
}

%%% INTRODUCTION %%%
\newchapter{1}{Introduction}
I built a system to help prevent crashes in rowing boats. The system is implemented in hardware, culminating in a series of boxes that can be attached to boats. The project is split into two parts. First, the mobile ad hoc network (MANET) allows nodes to communicate a dynamic collection of known obstacles, then the application layer warns users when they are approaching an obstacle and allows the user to add obstacles. The free and open source system will be available online, fully documented, after my graduation. This will include a `how to' guide [\hyperref[appendixA]{Appendix A}] for the construction of a node so any rowing club can use my project as a collision avoidance tool. The system achieved its goal as it warned users of upcoming obstacles. \\

\section{Motivation}	
Crashes between rowing boats and obstacles or other boats injure rowers and cause equipment damage. Unfortunately, crashes are common. Figure 1.1 shows a boat on the Thames, having collided with a bridge at a regatta in March 2023. Some boats have coxswains, responsible for steering a boat, while others are coxless, where rowers who face away from the direction of travel are responsible for steering boats. This project is designed for use in both coxed and coxless boats. \\
My project has a very personal motivation, as a friend was hit by a larger rowing boat while in a single three years ago, causing a severe concussion that resulted in two years of intermission from their studies. \\
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{boatCrash.jpg.png}
\end{center}
\caption{An eight colliding with Barnes Bridge\textsuperscript{1} \\ \footnotesize\textsuperscript{1} Simon Ramskill, Twitter post, March 2023, \url{https://twitter.com/lliksmar/status/1637147870682906624?cxt=HHwWgIC8zY_UqLgtAAAA}, Accessed March 2023}
\end{figure}
\stepcounter{footnote}

\subsection{Users}
Olympian and Cambridge Student, Imogen Grant said:
\emph{``Rowing is meant to be a non-contact sport, but it has a surprising incidence of concussions as a result of head on collisions, even at national and international level. We sit facing backwards, so steering involves looking over a shoulder in between strokes. The boats that I row in - singles and doubles - don't even have rudders and our steering is entirely reliant on pressure steering alone. Having warning of an obstacle would improve my confidence while sculling, and would mean that I could focus more on improving my technique rather than worrying that I might injure myself by crashing into something''}


\section{Background}
% tell a better story here, it feels jerky with the jump from the first network to today 
\subsection{Networking}
The Defence Advanced Research Projects Agency (DARPA) Packet Radio Network (PRNET) \cite{prnet} was the first wireless data network, using store-and-forward routing over packet radios. Jubin and Tornow lay out the state of PRNET in 1987, nearly 15 years after research began on it, in their paper \emph{The DARPA Packet Radio Network Protocols}. The work on PRNET fed into DARPA's Survivable Radio Network (SURAN) \cite{suran}. The connection between the military and ad hoc networking still exists today, with MANETs used in conflicts \cite{military}, as well as autonomous vehicles \cite{vehicle} and disaster relief scenarios where previously existing infrastructure is destroyed \cite{disaster}. \\ \\
%As technology improved, radio cards were made available for personal computing in the 1990s 
Each node in a MANET is free to move  in any direction, so the topology of the network changes in an unpredictable way. Rowing boats frequently move at speeds greater than 15 km/h, making the topology of any network of boats unpredictable and dynamic. Every node in a MANET must forward traffic, making it a router. In addition to this, the network may move between rivers, meaning no existing infrastructure would be available. These form the primary challenge for my network; routing messages through the network without pre-existing infrastructure, giving each node enough information to pass traffic to other nodes. \\
This is made more difficult by the small CPU and memory on the Raspberry Pi Pico \cite{rp2040}, limiting the processing power and information each node has.  \\
\subsection{Medium Access Control}
While routing corresponds to many hops across a network, medium access control considers only one. Media access control protocols control access to the transmission media to prevent collisions between packets. This project implemented media access control to prevent packets colliding and subsequently being corrupted. \\
\subsection{OSI Model}
The Open Systems Interconnection (OSI) model for computer networking provides a standardisation for communication over a network. The OSI model consists of seven layers: Application, Presentation, Session, Transport, Network, Data Link, and Physical \cite{ib}. Based on this model, my project uses the libraries provided with hardware for the physical and data link layers. It focuses mainly on the networking layer, sending messages between nodes. \\

\section{Related Work}
\subsection{Networking}
There is precedent for using MANETs on rowing boats. I spoke to the team behind the broadcasting and associated telemetry for the Oxford Cambridge Boat Race. They use a 15-node MANET to get the video and telemetry from the rowing boats. They also take GPS readings for the location of the boat, recording the location of the boat up to 20 times a second. Figure 1.2 shows the equipment attached to the boats for the 2023 Boat Race.  
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.07]{boatrace1.jpg}           \includegraphics[scale=0.07]{boatrace2.jpg}
\end{center}
\caption{Equipment placed on the stern of the Cambridge boat \cite{mike}}
\end{figure}

\subsection{Delay Tolerant Routing}
Delay tolerant routing assumes that networks will lack connectivity, with partitions between nodes. Vahdat and Becker's paper \emph{Epidemic Routing for Partially-Connected Ad Hoc Networks} \cite{epidemic} introduces a replication-based, delay-tolerant routing protocol where messages are passed onto nodes that do not have a copy of the message. Vahdat and Becker's paper is the key paper used to implement routing within this project. \\

\subsection{Safety in Rowing}
ROWCUS \cite{rowcus}, a company based in Switzerland, has attempted to solve the problem of crashes in rowing boats. While ROWCUS has similar goals to my project, the technical methodologies are different, using radar rather than GPS location to detect proximity to obstacles. Additionally, ROWCUS does not network nodes together, instead using individual nodes. ROWCUS has \emph{``decided not to pursue the commercial deployment of ROWCUS''}, in a statement on their website \cite{rowcus}. \\


%%% PREPARATION %%%
\newchapter{2}{Preparation}
\setcounter{figure}{0}
\section{Starting Point} 
I had no previous experience with microcontrollers, although I had worked with single-board computers. Therefore, over summer I dedicated a small amount of time to learning about microcontrollers and MicroPython, completing basic tasks such as flashing an onboard LED. While this was useful, my project was implemented in CircuitPython, so it would have been more beneficial to have learnt about this. \\ \\
I had some experience with networking and routing protocols prior to starting this project. This was composed of the Part IB Networking module and two weeks' work during an internship on a MANET with a different routing protocol, much further abstracted than this project. During my project, I took the \emph{Part II Principles of Communications} course, further expanding my knowledge. \\

\section{Requirements}
The three requirements I identified as my success criteria were: \\ \\
\textbf{\begin{tabular}{ll}
The Epidemic routing protocol is implemented within the network    & Achieved \\
An evaluation of the network has been carried out    & Achieved \\
An application layer has been implemented to allow utility of the network  & Achieved \\
\end{tabular}} \\ \\
All of these requirements have been implemented during this project. \\ \\ 
I also laid out several extension tasks. The key extension was medium access control. Other extension tasks were drawn from my research into networking protocols other than Epidemic. For instance, using a metric to of transmission quality -- received strength signal indicator (RSSI) in radio communication -- to influence whether an anti-entropy session was initiated. Additionally, the GPS location could be used, either by only contacting nearby nodes to increase the probability that an anti-entropy session is successful, or prioritising sending messages about new obstacles to nodes that are near these obstacles. While time constraints have not allowed me to implement all extensions, I have allowed messages to have two priorities, normal and urgent. \\

\subsection{Analysis}
The requirements for this project came from analysis of the problem; they were building blocks for a system to help prevent crashes in rowing boats. This means nodes would be attached to rowing boats, which the have high mobility and frequently move at speeds around 15 km/h. The networks generated by rowing boats have a high chance of partition and are unpredictable. This topology required a degree of flexibility within the network, pointing towards a delay tolerant routing protocol. The limited compute power available was also a consideration. I chose to implement Epidemic as it is a delay-tolerant routing protocol and best suited to the network topology likely to be generated by rowing boats \cite{epidemic}. \\
As the nodes in the network were all going to communicate on the same medium, some medium access control would have to be implemented in order to prevent collisions between messages. This was added as an extension criteria \\

\subsection{Network Topology}
Many of my requirements were based around the topologies of networks generated by rowing boats. The potential topology of networks was therefore analysed. This was done by looking at example distributions of rowing boats on lakes and rivers. I analysed Google Maps and Earth's satellite view of the Thames along a 5.5km stretch of the Championship Course, pinpointing rowing boats and coaching launches, adding them to a map with potential connections between nodes, assuming the radios have a range of 500m, alongside obstacles. Figure 2.1 shows a satellite image of two rowing boats, potential nodes in this network. Figure 2.2 shows the annotated map of the Thames, and Figure 2.3 presents the abstracted network topology of these rowing boats.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{earthSculler.jpg}
\end{center}
\caption{Two rowing boats seen on Google Earth \cite{earth}}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{mapsmarked.jpg}
\end{center}
\caption{Rowing boats, potential obstacles and assumed connections marked on a Google Maps map of the river Thames \cite{googlemapsgeneral}}
\end{figure}
\FloatBarrier
\begin{figurehere}
\begin{center}
\begin{tikzpicture}[bullet/.style={circle, fill, inner sep=2.5pt}]
    \foreach \lab [count=\c, 
                   evaluate=\c as \ang using {18+72*\c}] 
    in {a, b, c, d, e} {
       \node[bullet] (\c) at (\ang:10mm) {};
       \node at (\ang:14mm){};
       \foreach \i in {1,...,\c} {
          \draw[blue](\i)--(\c);
       }
    }
\node[bullet] (6) [right=of 5] {};
\node[bullet] (7) [right=of 6] {};
\draw[blue] (5) -- (6);
\draw[blue] (6) -- (7);
\node[bullet] (8) [right=5cm of 1] {};
\node[bullet] (9) [right= of 8] {};
\node[bullet] (10) [below= of 8] {};
\node[bullet] (11) [below= of 9] {};    
\draw[blue] (8) -- (9);
\draw[blue] (8) -- (10);
\draw[blue] (8) -- (11);
\draw[blue] (9) -- (10);
\draw[blue] (9) -- (11);
\draw[blue] (10) -- (11);
\node[bullet] (12) [right=8cm of 1] {};
\node[bullet] (13) [below =of 12] {};
\draw[blue] (12) -- (13); 
\end{tikzpicture}
\begin{tikzpicture}[bullet/.style={circle, fill, inner sep=2.5pt}]
    \foreach \lab [count=\c, 
                   evaluate=\c as \ang using {36+72*\c}] 
    in {a, b, c, d, e} {
       \node[bullet] (\c) at (\ang:10mm) {};
       \node at (\ang:14mm){};
       \foreach \i in {1,...,\c} {
          \draw[blue](\i)--(\c);
       }
    }
\node[bullet] (6) [right=of 5] {};
\node[bullet] (7) [right=of 4] {};
\node[bullet] (8) [right=4cm of 2] {};
\draw[blue] (5) -- (6);
\draw[blue] (6) -- (7);
\draw[blue] (6) -- (8);
\draw[blue] (4) -- (6);
\draw[blue] (5) -- (7);
\draw[blue] (6) -- (8);
\draw[blue] (7) -- (8);
\draw[blue] (4) -- (7); 
\node[bullet] (9) [right=3cm of 8] {};
\end{tikzpicture}
\end{center}
\caption{The network of rowing boats in an abstracted form, with nodes shown in black and assumed connections in blue }
\end{figurehere}
\FloatBarrier
\smallskip

\section{Summary of Research}
\subsection{MANETs}
A mobile ad hoc network (MANET) is characterised by wireless nodes, a frequently changing network topology and no reliance on pre-existing infrastructure. They are decentralised and therefore have no single point of failure \cite{d2}.  This project constructs a MANET between rowing boats to communicate obstacles to each other. A MANET was implemented due to the lack of pre-existing infrastructure for such a system and the difficulties associated with setting up and maintaining a base station or similar. Requiring an infrastructure like this would also raise the barrier to entry for many clubs with limited funds and technical skills. Additionally, rowing boats can move between stretches of water, further supporting the use of a MANET for this project. \\

\subsection{Routing}
Routing protocols find a path from a source to one or more destinations destination within the network. Different routing protocols optimise different parameters and are better suited for different network topologies and applications \cite{princom}. Within MANETs, a routing protocol must allow the network topology to change over time. They tend to contain node discovery techniques to allow for this. \\ \\
Before deciding on Epidemic routing for the project, several other protocols were considered. The Better Approach to Ad Hoc Mobile Networking (BATMAN) routing protocol \cite{batman} is designed to route messages through MANETs, broadcasting originator messages (OGM) for node discovery. BATMAN has the interesting addition of a transmit quality (TQ) metric in the OGM packets, allowing the quality of connections between nodes to be factored into the route packets take through the network. While BATMAN does allow messages to be broadcast to all nodes, its primary focus is routing messages from one node to another. Additionally, while it allows for message mobility, it is not delay-tolerant.\\ \\
Greedy Perimeter Stateless Routing (GPSR) is a location-based routing protocol \cite{gpsr}. GPSR exploits the relation between geographic position and connectivity in a wireless network, where each node tells its immediate neighbours its current location. Greedy forwarding is predominantly used to send packets to nodes that are progressively closer to the destination until the destination coordinates can be reached. Where greedy forwarding fails, GPSR uses perimeter forwarding (forwarding the packets around the perimeter of the region) until greedy forwarding can be used again. This protocol was ultimately deemed to be unsuitable for my project as, similar to BATMAN, its primary focus is on sending messages between two nodes. Additionally, the high mobility of the nodes in the use case means that forwarding packets to a set of coordinates does not mean the message will reach the intended destination, as the node may have moved. \\

\subsection{Epidemic}
Epidemic routing was implemented as it is a delay-tolerant routing protocol and best suited to the network topology likely to be generated by rowing boats \cite{epidemic}. The networks generated by rowing boats have a high chance of partition, and the nodes are highly mobile. Epidemic routing allows all nodes to carry information through the network. This makes it useful for the potential topology of the use case. Additionally, Epidemic routing supports a broadcast functionality, sending messages to every node in the network, which is necessary for the use case as every boat should hear about potential obstacles. \\
Epidemic routing gains its name from its similarity to the spreading of infections. Each node holds a buffer of messages that it has seen. When a node comes into contact with another node it has not recently contacted, it replicates and transmits messages this neighbour. This message exchange is known as anti-entropy. \\

\subsubsection{Anti-Entropy}
The term `anti-entropy', as used in my dissertation, comes from Vahdat and Becker's paper. Anti-entropy is the process of exchanging messages to pass them through the network. It is a key part of Epidemic routing. A more detailed explanation is in the Implementation section, although a brief overview is provided here. \\
When two nodes come into communication range, they transfer messages the other node has not seen to each other. Each node then stores these messages to exchange later. 

\subsection{Medium Access Control}
While these routing protocols often have mechanisms to minimise the probability of collisions, such as adding a jitter in the sending of discovery messages, none of them contain medium access control. Due to the probability of collisions between messages causing disruption to the sending of messages, particularly as all nodes are broadcasting on the same radio frequency (433 MHz). It was  therefore prudent to include media access control in the system. \\
Multiple Access with Collision Avoidance for Wireless (MACAW) is often used by ad hoc networks \cite{macaw}. MACAW uses request to send (RTS) and clear to send (CTS) messages to minimise the probability of collision. As discussed in the System Design section, MACAW inspired the medium access control in my project. \\

\subsection{Serial Communication}
Serial communication protocols were used to transmit data between the Raspberry Pi Pico and peripherals. All data was transferred over relatively short distances. The two main protocols used were the serial peripheral interface (SPI) and universal asynchronous transmitter / receiver (UART) protocols. 
\subsubsection{SPI}
SPI is a full duplex synchronous serial communication interface. The communication is synchronised by a clock signal, output from the controller on Serial Clock (SCLK). The four logic signals specified are SCLK, Peripheral Out Controller In (POCI), Peripheral In Controller Out (PICO), and Chip Select (CS). 
\begin{figurehere}
\begin{center}
\begin{tikzpicture}
[node/.style={rectangle, draw=black, very thick, minimum size=30mm}]
\node[node] (A) {};
\node[node] (B) [right =3cm of A] {};
\draw[-latex, line width=0.5mm, red] (A.30)--(A.30-|B.-150) node[left =3cm] {SCK} node[right]{SCK};
\draw[-latex, line width=0.5mm, blue] (A.10)--(A.10-|B.-150) node[left =3cm] {PICO} node[right]{PICO};
\draw[-latex, line width=0.5mm, green] (B.-170)--(A.-10) node[right = 3cm] {POCI} node[left]{POCI};
\draw[-latex, line width=0.5mm, gray] (A.-30)--(A.-30-|B.-150) node[left =3cm] {CS} node[right]{CS};
\end{tikzpicture}
\end{center}
\caption{SPI logic signals}
\end{figurehere}
\subsubsection{UART}
The UART protocol allows for full duplex, asynchronous communication. The controller and peripheral do not share a clock signal, but transmit at the same agreed speed. Data is transmitted using the UART frame format. 
\begin{figurehere}
\begin{center}
\begin{tikzpicture}
[node/.style={rectangle, draw=black, very thick, minimum size=18mm}]
\node[node] (A) {};
\node[node] (B) [right =3cm of A] {};
\draw[-latex, line width=0.5mm, red] (A.20)--(A.20-|B.-150) node[left =3cm] {TX} node[right]{RX};
\draw[-latex, line width=0.5mm, blue] (B.-165)--(A.-15) node[right = 3cm] {TX} node[left]{RX};
\end{tikzpicture}
\end{center}
\caption{UART logic signals}
\end{figurehere}

\section{Software Development}
\subsection{Methodology}
Most software development methodologies are designed for use within a team of programmers working over a long period and are not suited for a 
Part II project. I therefore integrated key components from several software development methodologies, particularly the waterfall and agile methodologies. \\ \\
The waterfall model of software development is based around the five stages: \\
\centerline{Requirements $\rightarrow$ System Design $\rightarrow$ Implementation $\rightarrow$ Testing $\rightarrow$ Maintenance} \\ \\
From the waterfall model of software development, I took the focus on planning and documentation, particularly as I wanted others to be able to reproduce my results. \\ \\ 
Agile software development is based on 12 principles that highlight responding to change and generating working software \cite{agile}. \\
I integrated the tenets \emph{``Simplicity -- the art of maximizing the amount of work not done -- is essential''} \cite{agilep} and \emph{``Welcome changing requirements, even late in development.''} \cite{agilep} into the project.  \\ \\ 
The work to be done was broken down into blocks, with concrete deliverables as criteria for completion of each block. This helped prevent scope creep and keep me on track for each part. I also tested each component of the project as it was built, ensuring that it worked and making debugging the final product easier. \\

\subsection{Programming}  
This project used CircuitPython, a branch of MicroPython, an implementation of Python 3 for microcontrollers. CircuitPython was used as it can easily be run on the Raspberry Pi Pico. Additionally, it allowed me to use Pylint to statically analyse code. This was particularly useful as the code was run on an external Raspberry Pi Pico, so running the code to find small errors would have been time consuming. Additionally, the existing AdaFruit libraries I used in the project were written in CircuitPython, so keeping the whole project in the same language reduced complexity. \\ \\
GitHub was used to perform version control on the code and dissertation for this project. This also allowed me to fork others' repositories and submit a pull request to AdaFruit. \\ \\ 
I used Visual Studio Code as my main integrated development environment (IDE) as I have used it in previous projects, and it offered support for CircuitPython via an extension. \\

\subsection{Licencing}
The project is licenced under the MIT licence. All libraries used in the project are licenced under the same or more permissive licences. The MIT licence was chosen as it allows the project to use these libraries, and as it allows others to use and expand the system. \\

\section{Choice of Hardware} 
Hardware was ordered before the start of the Michaelmas term, in order to guarantee its availability for the project proposal. The main factors in my hardware choices were size, weight, power consumption and cost. Items needed to be relatively small to allow them to fit on a rowing boat. If the components were overly costly, it may prohibit other rowing clubs from producing their own networks. \\ \\
I chose to use a microcontroller to run the system due to the reduction in power consumption and costs it would offer over a single-board computer. The Raspberry Pi Pico is an microcontroller with a dual-core Arm processor \cite{rp2040}. One unit costs Â£3.90 at the time of writing \cite{buypico}. The price factored into my choice of microcontroller so it would be affordable for most rowing clubs. It was also chosen due to its large peripheral set, with support for both UART, SPI, and I2C protocols. This allowed for greater flexibility throughout the project. Figure 2.6 shows the pinout for the Raspberry Pi Pico. 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.2]{picopinout.png}
\end{center}
\caption{The pinout for the Raspberry Pi Pico. Unchanged from Raspberry Pi, licenced under the Creative Commons Attribution-ShareAlike 4.0 licence \cite{pinout}}
\end{figure}
For GPS and radio, AdaFruit boards were chosen due to the strong community surrounding the hardware, with the AdaFruit boards being supported by open source libraries that allow rudimentary operations to be performed. \\
The AdaFruit RFM69 radio has an SPI interface and 500m range, appropriate for the use case as rowing boats will take around 2 minutes to cover 500m. Additionally, I chose to use the 433 MHz industrial, scientific, and medical (ISM) band as it is free to use without licencing, allowing me and other rowing clubs to use it without incurring additional costs. \\
The CD-PA1616S GPS has benefits similar to the RFM69, with community support and libraries for basic communication. It was additionally chosen as it includes a patch antenna and a relatively short cold start time -- these were important for the use case, as a delay in the collision avoidance device starting up reduces the overall utility of the system. \\

\section{Timeline}
The Project Proposal laid out a timeline for the creation of the system. For the most part, this timeline was followed, with the exception of implementing the MANET, which took longer than the time allowed. Figure 2.7 shows a Gantt chart with the proposed and actual timelines.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{gantt.pdf}
\end{center}
\caption{A Gantt chart with proposed and actual timelines}
\end{figure}



%%% IMPLEMENTATION %%%
\newchapter{3}{Implementation}
\setcounter{figure}{0}
% talk about the end of each stage where you tested the components 
%This chapter should describe what was actually produced: the programs which were written, the hardware which was built or the theory which was developed. 
% design strategies that looked ahead to the testing stage should be described in order to demonstrate a professional approach was taken.
%Descriptions of programs may include fragments of high-level code but large chunks of code are usually best left to appendices or omitted altogether. 
% Split into major blocks with the testing at the end ``It should not be necessary to give a day-by-day account of the progress of the work but major milestones may sometimes be highlighted with advantage.''
%Should definately make a new state machine / UML diagram to show how the code now works 
%On delays (back-off etc.) -- the delays currently seem quite long, and there'll need to be some justification in the Implementation chapter for how you chose the length of the delays. Usually I'd expect delays of the order of milliseconds rather than seconds. A sensible way to choose the delays would be: on your oscilloscope, time the total length of time required to complete one full exchange with another node, and then set the default back-off to that (and take a similar approach to any other delays in the program).
% talk about the name change
% They do assume you can program so don't overley detail how your code is structured.
% Highlight the requirements as you achieve them
% How are things scheduled on the pico? How is code compiled for the pico? 
% talk about how the project was implemented, starting with the system design and then implementing in blocks 

\section{Final System}
\subsection{Hardware}
Figure 3.1 shows a wiring diagram of the system, produced on Fritzing software, so others can replicate the system. Figure 3.2 shows a virtual breadboard with the system included, again so others can replicate it. Figure 3.3 is an image of the final system, before it is contained in a box. I have soldered the Raspberry Pi Pico `upside down' so I can more easily view the pin numbers, so while the wiring in Figures 3.2 and 3.3 seems different at first glance, it is all the same. 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.8]{wiring.pdf}
\end{center}
\caption{A wiring digram for the system}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics{breadboard.pdf}
\end{center}
\caption{A virtual breadboard with the system}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.15]{insideBox.jpeg}
\end{center}
\caption{The wiring of the final system}
\end{figure}
\FloatBarrier

\subsection{Software}
Figure 3.4 shows the final state machine representing the software running on the Raspberry Pi Pico. The software differs slightly from the software designed, although both designs have the same effects. The two key differences are in the Epidemic routing protocol and multithreading. \\ 
Within Epidemic, routing packets were merged with the medium access control packets to minimise the number of packets used in each anti-entropy session. This is discussed in more detail under the Epidemic section. \\
Unfortunately, some of the hardware did not have libraries that worked in MicroPython. Therefore, the system was not multithreaded, but ran all on one thread. This is further detailed in the MicroPython section.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{finalMachine.pdf}
\end{center}
\caption{The final state machine representation of the software}
\end{figure}
\FloatBarrier



\subsection{Packet Design}
The structure of the packets sent within the network is standardised. These structures are influenced by the structures of packets in previous routing protocols I examined,particularly BATMAN \cite{batman}. I attempted to keep the structure of the start of the packets  Figures 3.5 and 3.6 show the overall design for packets sent on the network. The preamble for all packet types start with the length of the packet so the system knows how much data to expect. Figures 3.7 to 3.9 show the breakdown of the payload by packet type, given that the preamble is the same for all packets.  \\ \\
The address \verb'0x00' is designated for broadcast, then each node numbered sequentially and uniquely. This limits the number of nodes a network can contain to be 255.
\begin{figure}[h]
\begin{center}
\begin{tabular}{ |c|c|c|c|c| } 
\hline
\textbf{Bytes /} & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} \\ 
\textbf{Offset} &  &  &  &  \\ 
\hline
\textbf{0} & Length & Packet Type & Sender & Destination \\ 
\hline
\textbf{1} &     \multicolumn{4}{c|}{Payload}  \\ 
\hline
\textbf{2} &     \multicolumn{4}{c|}{Payload}  \\
\hline
 - & \multicolumn{4}{c|}{....................................}  \\
\hline
\textbf{14} & \multicolumn{4}{c|}{Payload}  \\
\hline
\textbf{15} & \multicolumn{4}{c|}{Payload}  \\
\hline
\end{tabular}
\end{center}
\caption{The preamble for all packet types}
\end{figure}

\begin{figure}[h]
\begin{center}
\begin{tabular}{ |c|c| } 
\hline
\textbf{Packet Type} &  \textbf{Hexadecimal Representation} \\
\hline
HELLO & \verb'0x00' \\ 
\hline
RTS &  \verb'0x01'  \\ 
\hline
CTS &   \verb'0x02'  \\
\hline
DATA &  \verb'0x03' \\
\hline
ACK &  \verb'0x04' \\
\hline
\end{tabular}
\end{center}
\caption{The types of packet}
\end{figure}


\begin{figure}[h]
\begin{center}
\begin{tabular}{ |c|c|c|c|c| }
\hline
\textbf{Bytes /} & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} \\ 
\textbf{Offset} &  &  &  &  \\ 
\hline
\textbf{1} &     \multicolumn{4}{c|}{GPS latitude}  \\ 
\hline
\textbf{2} &     \multicolumn{4}{c|}{GPS longitude}  \\
\hline
\textbf{3} &     \multicolumn{4}{c|}{Padding}  \\
\hline
 - & \multicolumn{4}{c|}{.........................................................}  \\
 \hline
\textbf{15} &     \multicolumn{4}{c|}{Padding}  \\
\hline
\end{tabular}
\end{center}
\caption{The payload of HELLO packet type}
\end{figure}

\begin{figure}[h]
\begin{center}\begin{tabular}{ |c|c|c|c|c| }
\hline
\textbf{Bytes /} & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} \\ 
\textbf{Offset} &  &  &  &  \\ 
\hline
\textbf{1} &     \multicolumn{2}{c|}{Message ID 0}  & \multicolumn{2}{c|}{Message ID 1}  \\ 
\hline
\textbf{2} &  \multicolumn{2}{c|}{Message ID 2}  & \multicolumn{2}{c|}{Message ID 3}   \\
\hline
 - & \multicolumn{4}{c|}{.........................................................}  \\
 \hline
 \textbf{14} &  \multicolumn{2}{c|}{Message ID 26}  & \multicolumn{2}{c|}{Message ID 27}   \\
\hline
\textbf{15} &   \multicolumn{2}{c|}{Message ID 28}  & \multicolumn{2}{c|}{Message ID 29}   \\
\hline
\end{tabular}
\end{center}
\caption{The payload of CTS and RTS packet types}
\end{figure}

\begin{figure}[h]
\begin{center}
\resizebox{\textwidth}{!}{\begin{tabular}{ |c|c|c|c|c| }
\hline
\textbf{Bytes /} & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} \\ 
\textbf{Offset} &  &  &  &  \\ 
\hline
\textbf{1} &   Total number of DATA packets expected  &  Number of this DATA packet & \multicolumn{2}{c|}{Requested Message ID 0} \\ 
\hline
\textbf{2} &  \multicolumn{4}{c|}{Requested Message Data}   \\
\hline
 - & \multicolumn{4}{c|}{.........................................................}  \\
 \hline
 \textbf{14} &  \multicolumn{2}{c|}{Requested Message Data}  & \multicolumn{2}{c|}{Requested Message ID 7}   \\
\hline
\textbf{15} & \multicolumn{4}{c|}{Requested Message Data} \\
\hline
\end{tabular}}
\end{center}
\caption{The payload of DATA packet types}
\end{figure}
\FloatBarrier

\subsection{Open Source}
The system was designed and documented so it could be reproduced by other rowing clubs and used to help prevent crashes. Due to plagiarism rules the repositories and documentation, including README, have not yet been made available. They will be made public immediately after my graduation. \\
The repository is licenced under the MIT licence, allowing others to use and expand on the system. \\


\section{System Design}
Before designing the system, it was decided the system would identify obstacles using GPS coordinates. The Epidemic routing protocol would be used to propagate obstacles through the network. Users need to be notified of upcoming obstacles and be able to add new obstacles. \\
From these criteria, the structure of the software to run on each node was designed. The Raspberry Pi Pico uses the RP2040 chip, containing two cores \cite{rp2040}. To make best use of the hardware, application and networking threads were designed to run on each core. Global data structures and concurrency control were chosen to pass messages between the two layers and allow both layers access to the GPS. \\ \\
While these state machines were broadly implemented, the overall structure of the software changed, with only one thread running due to the limitations of CircuitPython and difficulties transitioning into MicroPython. \\


\subsection{Application}
The application thread was responsible for notifying the user when they are too close to an obstacle and allowing them to add obstacles. The initial state machine is shown in Figure 3.10. 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{app.pdf}
\end{center}
\caption{The initial state machine for the application thread}
\end{figure}
\FloatBarrier

\subsection{Networking}
% literially anything about the flooding state machine thing
The networking thread was designed to propagate messages through the network. It contained the implementation of Epidemic with medium access control. While routing and medium access control are typically handled separately -- in the OSI model they are in the second and third layers respectively -- they were considered together in this system to prevent work being repeated and use limited computing resources effectively. These traditionally separate layers were combined as some data structures, such as the contacted node dictionary, would need to be shared between layers, increasing complexity and compute time. Figure 3.11 shows the Networking machine. \\
This meant Vahdat and Becker's implementation of Epidemic was adjusted. A quiet state was defined, where a node did not send any messages after hearing a CTS for a set period of time, or until it hears an ACK. The message vector exchange was combined into the CTS and RTS messages. This minimised the number of packets sent over the network, reducing the probability of collisions or errors in transmission.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{appLayer.pdf}
\end{center}
\caption{The initial state machine for the networking thread}
\end{figure}
\FloatBarrier

\subsection{Data Structures}
\subsubsection{Global}
The global data structures would be accessed by both threads, with associated locks to ensure that both threads do not access the structure at the same time. \\ \\
\resizebox{\textwidth}{!}{\begin{tabular}{ l l l }
\hline
\textbf{Structure} & \textbf{Construction} & \textbf{Notes} \\  
\hline
Location & Tuple of (longitude, latitude) &  Calls a function that communicates with \\
& & the GPS board \\ 
\hline
ApplicationToNetwork & Queue of obstacles &  Application machine pushes user defined \\
& & obstacles onto queue so they can be \\
& & propagated through the network\\ 
\hline
NetworkToApplication & Queue of obstacles & Network machine pushes messages propagated \\
& & through the network to the application layer\\ 
\hline
\end{tabular}}


% The initial idea here is to for a routing or application layer to push data onto the queue
% The network layer tkaes care of deduplication?
% like 10 pages and 2000 words coming on ouch 
\subsubsection{Application}
\resizebox{\textwidth}{!}{\begin{tabular}{ l l l }
\hline
\textbf{Structure} & \textbf{Construction} & \textbf{Notes} \\  
\hline
Obstacles & List of obstacles and their TTL & A list of obstacles and their TTL. Any obstacles\\
& &   with a TTL of -1 are considered permanent \\
\hline
\end{tabular}}

\subsubsection{Networking}
\resizebox{\textwidth}{!}{\begin{tabular}{ l l l }
\hline
\textbf{Structure} & \textbf{Construction} & \textbf{Notes} \\  
\hline
Messages & Dictionary of & The messages' ID is constructed from the \\
& \{Message ID : [Latitude, Longitude, TTL]\}  &  generating node ID and the number of messages \\
& &  that node has generated\\ 
\hline
\end{tabular}}
\FloatBarrier

\section{Debugging}
Throughout the project, different pieces of hardware and unusual issues needed to be debugged. To debug hardware, a multimeter was used to detect if data was being sent along various connections. On occasions when the multimeter could not be accessed, the anode of an LED was attached to the connection being examined and the cathode grounded. The LED would light up when data was passing through this connection. \\
When debugging more persistent issues, such as the MicroPython-CircuitPython communication, my supervisor kindly lent me a logic analyser. Figure 3.12 shows a node being examined with a logic analyser. \\ \\ 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.2]{logicAnalyser.jpeg}
\end{center}
\caption{A logic analyser being used to examine the signals sent from the Raspberry Pi Pico to the RMF69}
\end{figure}


\section{Logging}
Logging was done via a bespoke class. The class had functions to handle different types of log. It output series of statements, printed and saved to the flash memory on the Pico in a `logging.txt' file. This allowed easy modelling of the relationships between nodes. The docstring from the logging class reads:\begin{verbatim}
Class with multiple functions to handle logging
    
Logs: 
    Node Address, Time, Time Since Node Startup, Event Type, Event Information

Event Types:
    0   -   General logging string
    1   -   Logging function
    2   -   Logging packet
    3   -   Logging messages
    4   -   Logging error
    5   -   Logging GPS location
    6   -   Logging an alert
    
\end{verbatim}


\section{Point to Point}
Before starting to implement Epidemic, I ensured that the two nodes in line of sight could communicate. This was successful; each node could send a packet to another node. Several interesting variables were found in the communication between point to point nodes. \\ \\
A quarter wave whip antenna was used -- a piece of wire cut to 17.4 cm (1/4 of the wavelength) and soldered to the antenna port and ground plane. I found that the thickness of the wire had an impact on the signal, with thicker wire having a longer range. This is likely due to the lower resistance of ticket wire. Figure 3.13 shows the antenna of varying thickness on three of the radio. 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.1]{wires1.jpeg}           \includegraphics[scale=0.12]{wires2.jpeg}
\end{center}
\caption{A selection of antenna on the radios}
\end{figure}
\FloatBarrier
It was also found that when the rate and length of packets sent increased, more errors were found in transmission and decoding. To fix this, I wanted to move to fixed length packets, padded with 0s. However, the \verb'adafruit_rfm69' library did not allow for fixed length packets. I therefore added this functionality. I consulted the RFM69HCW datasheet \cite{radiodata}, set the packet format register to 0 (indicating fixed length) and the packet length to 64 (the size of the FIFO buffer). I integrated configurable length fixed length packets into a fork of the \verb'adafruit_rfm69' library \cite{radiogit} and have submitted a pull request so others can use this functionality. \\ \\

\section{Epidemic}
\subsection{Discovery Messages}
The point to point messages were then moved to sending and receiving discovery messages, of type \verb'0x00', also known as HELLO packets. These messages used the broadcast address, \verb'0x00'. These packets used structure defined in the Final System section. To test discovery packets, it was ensured that HELLO packets were correctly sent and received. The payload of HELLO packets contained the node's current GPS location, so it could be recognised as an obstacle by other nodes. When first initiated, this location was generated by a stand in function that gave a random set of numbers, later replaced by a call to the GPS board. 

\subsection{Anti-Entropy}
When a new node is discovered, anti-entropy will occur. An anti-entropy session allows nodes to exchange messages and occurs when two nodes come into communication range. In Vahdat and Becker's Epidemic paper \cite{epidemic}, anti-entropy is initiated by the node with the lower ID to prevent collisions. Figure 3.14 shows the first half of anti-entropy. Node A, with a lower ID, initiates anti-entropy by sending a summary vector (SV\textsubscript{A}) to node B. This summary vector is represents the messages node A holds. Node B calculates the logical AND between this summary vector and the negation of its own summary vector (SV\textsubscript{B}) to produce the messages it has not seen, but the other node holds. It sends this request (SV\textsubscript{A} + $\neg$ SV\textsubscript{B}) to node A. Node A responds by sending the requested messages to node B. \\
The roles are then reversed, with node B sending its summary vector (SV\textsubscript{B}) to A. A requests messages it has not seen from B (SV\textsubscript{B} + $\neg$ SV\textsubscript{A}) and receives them. \\
After a successful message exchange, node B is added to node A's list of recently contacted nodes, preventing anti-entropy from being repeatedly conducted between two nodes. This list is periodically cleared. \\
\begin{figurehere} 
\begin{center}
\begin{tikzpicture}
[node/.style={circle, draw=black, very thick, minimum size=30mm}]
\node[node]      (A)         {\Huge A};
\node[node]        (B)    [right =3cm of A]   {\Huge B};
\draw[-latex, line width=0.5mm, blue] (A.30)--(A.30-|B.-150) node[midway, above] {SV\textsubscript{A}};
\draw[-latex, line width=0.5mm, red] (B)--(A) node[midway, above] {SV\textsubscript{A} + $\neg$ SV\textsubscript{B}};
\draw[-latex, line width=0.5mm, blue] (A.-30)--(A.-30-|B.-150) node[midway, above] {Messages};
\end{tikzpicture}
\end{center}
\caption{The first stage of anti-entropy \cite{epidemic}}
\end{figurehere} 
\bigskip

The implementation of Epidemic routing in this project is broadly the same as Vahdat and Becker's, initiated by the lower ID node. However, the implementation in this project combines medium access control with the exchange of summary vectors, with SV\textsubscript{A} being combined with the RTS and SV\textsubscript{B} combined with CTS. These contained the message keys that are held on that node. \\
The other key difference is in requests. As all nodes use the same mechanism to construct a request to send to the other nodes, this can be moved off node. Once a node has received the summary vector from the other node, it will calculate the messages the node wants by comparing the message keys each node holds (SV\textsubscript{A} + $\neg$ SV\textsubscript{B}). This removes two messages from the anti-entropy process, reducing the opportunity for error. Figure 3.15 shows updated anti-entropy.

\begin{figurehere} 
\begin{center}
\begin{tikzpicture}
[node/.style={circle, draw=black, very thick, minimum size=30mm}]
\node[node]      (A)         {\Huge A};
\node[node]        (B)    [right =3cm of A]   {\Huge B};
\draw[-latex, line width=0.5mm, blue] (A.60)--(A.60-|B.-120) node[midway, above] {RTS (SV\textsubscript{A})};
\draw[-latex, line width=0.5mm, red] (B.155)--(A.25) node[midway, above] {CTS (SV\textsubscript{B})};
\draw[-latex, line width=0.5mm, blue] (A)--(B) node[midway, above] {DATA};
\draw[-latex, line width=0.5mm, red] (B.-155)--(A.-25) node[midway, above] {DATA};
\draw[-latex, line width=0.5mm, blue] (A.-60)--(A.-60-|B.-120) node[midway, above] {ACK};
\end{tikzpicture}
\end{center}
\caption{The anti-entropy implemented}
\end{figurehere} 
\bigskip

The message exchange in the system design was also tweaked. Again, these changes were made to reduce the number of packets sent, and therefore the bandwidth taken up by the anti-entropy process and possibility for errors. The design has DATA FRAME (DF) and DATA packets, where the DF packet sets up the number of expected DATA packets. Instead of sending a separate packet, the number of DATA packets expected was designated the first byte of the payload. Each DATA packet given an ID, its number from the total. When the initiating node (A) has sent all its packets, it waits for the DATA packets sent from the other node as an acknowledgement all DATA packets have been received. If DATA packets are not seen within the timeout, set in the \verb'config.py' file, the node resends the DATA packets. If this is repeated as many times as defined in the \verb'config.py' file, the initiating node (A) ceases anti-entropy and enters the listening state again. \\ 
If node A successfully receives all DATA packets from node B, it sends an acknowledgement (ACK) to indicate no resends are necessary and ends the anti-entropy process. \\ \\
When the non-initiating node (B) sees it has received all the DATA packets from node A, and has sent all DATA packets, it waits for the ACK from A. If unseen after a certain time, specified in the \verb'config.py' file, it resends the DATA messages. Should the resends still not be acknowledged, the anti-entropy times out. Figure 3.16 shows a timing diagram for the implemented Epidemic routing. 
\begin{figure}[h]
\begin{center}
\tikzset{
    host/.style={rectangle,rounded corners,             
                  thick,draw=black},
    host/.default=black,
    trama/.style={thick,draw=#1,fill=#1, node font = \tiny},
    trama/.default=red,
    ack/.style={trama=blue},
}

\newcommand{\tramaok}[2]{%
    \draw[trama,->, node font = \tiny]  #2 --++(1.5,-2) node[above right,near start] {#1};
}
\newcommand{\tramaperduda}[2]{%
    \path #2 coordinate (a)--++(1.5,-2) coordinate (b) coordinate[midway] (c); 
    \draw[trama,-, node font = \tiny]  (a) --(c) node[below] {#1};
    \draw[trama,-> , node font = \tiny]  (c) -- ++(30:.5);
}

\newcommand{\ackok}[2]{
    \draw[ack,->, node font = \tiny] {#2}--++(1.5,2) node[below right,near start] {#1};
}

\newcommand{\ackperdut}[2]{
    \path #2 coordinate (a)--++(1.5,2) coordinate (b) coordinate[midway] (c); 
    \draw[ack,-]  (a) --(c) node[above] {#1};
    \draw[ack,->]  (c) -- ++(-30:.5);
}

\newcommand{\1}[3]{%
    \draw #1 --++(0,5mm);
    \draw #2 --++(0,5mm);
    \begin{scope}[yshift=2.5mm]
    \draw[-] #1 -- #2 node[above,midway, text = black!50,  node font = \tiny]{#3};
    \end{scope}
}

\newcommand{\4}[3]{%
    \draw #2 --++(0,5mm);
    \begin{scope}[yshift=2.5mm]
    \draw[<-] #1 -- #2 node[below,midway, text = black!50, node font = \tiny]{#3};
    \end{scope}
}


\newcommand{\3}[3]{%
    \draw #2 --++(0,5mm);
    \begin{scope}[yshift=2.5mm]
    \draw[<-] #1 -- #2 node[above,midway, text = black!50, node font = \tiny]{#3};
    \end{scope}
}

\newcommand{\5}[3]{%
    \draw #1 --++(0,5mm);
    \draw #2 --++(0,5mm);
    \begin{scope}[yshift=2.5mm]
    \draw[-] #1 -- #2 node[below,midway, text = black!50, node font = \tiny]{#3};
    \end{scope}}
\newcommand{\6}[3]{%
    \draw #1 --++(0,5mm);
    \begin{scope}[yshift=2.5mm]
    \draw[->] #1 -- #2 node[below, text = black!50,  node font = \tiny]{#3};
    \end{scope}}
\newcommand{\2}[3]{%
    \draw #1 --++(0,5mm);
    \begin{scope}[yshift=2.5mm]
    \draw[->] #1 -- #2 node[above,midway, text = black!50, node font = \tiny]{#3};
    \end{scope}}
\begin{tikzpicture}%[>=stealth]
\draw[help lines,->, node font = \Large, text = black] (-0.2,0) node[host,left] {B}--(13,0);
\draw[help lines,->,  node font = \Large, text = black] (-0.2,2) node[host,left] {A}--(13,2);
\tramaok{HELLO}{(0,2)}
\ackok{RTS}{(1.5,0)}
\tramaok{CTS}{(3,2)}
\ackok{DATA}{(4.5,0)}
\ackok{}{(5,0)}
\ackok{}{(5.5,0)}
\ackok{}{(6,0)}
\tramaok{DATA}{(7.5,2)}
\tramaok{}{(8,2)}
\ackok{ACK}{(9.5,0)}
\3{(0,2)}{(3,2)}{\textbf{Listening State}}
\1{(3,2)}{(6,2)}{\textbf{Received RTS State}}
\1{(6,2)}{(7.5,2)}{\textbf{Get Data State}}
\1{(7.5,2)}{(11,2)}{\textbf{CTS Send Data State}}
\2{(11,2)}{(13,2)}{\textbf{Listening State}}
\4{(0,-0.5)}{(1.5,-0.5)}{\textbf{Listening State}}
\5{(1.5,-0.5)}{(4.5,-0.5)}{\textbf{RTS Anti-Entropy State}}
\5{(4.5,-0.5)}{(9,-0.5)}{\textbf{RTS Send Data State}}
\5{(9,-0.5)}{(12.2,-0.5)}{\textbf{RTS Get Data State}}
\6{(12.2,-0.5)}{(13,-0.5)}{\textbf{Listening State}}
\end{tikzpicture}
\end{center}
\caption{Messages and states of two nodes completing anti-entropy with no missed messages}
\end{figure}
\bigskip 

These variables remain configurable to allow each user to choose values that work best for their use. The sensitivity analysis was the basis for the values I used when Evaluating and using the system.

\subsection{Pseudocode}
Figure 3.17 shows an abstracted and commented version of the Epidemic routing. Note that logging, error messages have been cut out. The full code is available in the code repository, under \verb'OnDevice > DeviceCode'.
\begin{figure}[h] 
\begin{verbatim}
if state == config.LISTEN:
    args = rfm69.receive()
    # Update the state based on any packets received
    state = handleReceive(args) 

elif state == config.RECEIVED_HELLO:
    # Add the location of the node that sent the HELLO to the obstacles list
    obstacles.append([float(newObstacle[0]), float(newObstacle[1]), 1])
    if sender not in contacted and sender>config.ADDRESS:
        # Anti-entropy initiated by this node
        success, messages = RTSAntiEntropy(dest = sender, messages = messages)
        if success:
            # Add the other node to the dictionary of contacted node 
            # on successful anti-entropy
            contacted.update({sender : config.CONTACTED_LIVES})
    state = config.LISTEN

    
elif state == config.RECEIVED_RTS:
    # Initiate anti-entropy from the side of sending a CTS       
    success, messages = CTSAntiEntropy(sender, messages, RTSpacket)
    state = config.LISTEN

if state == config.LISTEN and timers.hello():
    # Broadcast HELLO packet
\end{verbatim}
\caption{Abstracted Epidemic routing code}
\end{figure}
\FloatBarrier

\subsection{Sensitivity Analysis}
The value of each configurable value in the network was determined experientially. The most important of these was how often a HELLO packet would be sent. This has a direct impact on how often anti-entropy would be initiated, and therefore the latency of messages. \\ 
Figure 3.18 shows the latency of 30 messages being sent between two nodes with interference from another node. From this experimentation, I decided to send HELLO packets every 5 seconds (with a random jitter). This was a trade-off between collisions of HELLO packets, the power consumption involved in sending packets, and the latency of packets sent through the network.
\begin{figure}[h]
\begin{center}
\input{sensitivity.pgf}
\end{center}
\caption{The time taken to deliver messages over distance intervals}
\end{figure}
\FloatBarrier

\subsection{Testing}
Testing the Epidemic implementation ensured that it worked, particularly with edge cases. The edge cases tested involved: \\
Both nodes containing full messages dictionary, with 30 messages \\
One node holding some messages and one node with no messages \\
Both nodes having identical messages \\
Both nodes holding no messages \\ \\
This testing highlighted an issue with anti-entropy, where no DATA packets were sent if there were no messages the other node needed. This was rectified by sending one empty DATA packet to indicate that the node had no new messages. \\ \\
Once the edge testing was finished, I demonstrated the utility of the network by allowing the user to type in a message on the terminal of a laptop on one node. This message was passed to another node and displayed on the attached screen. \\

\section{Medium Access Control}
Medium access control was implemented alongside the Epidemic routing protocol, detailed in the previous section. If a node overheard the exchange of an RTS / CTS message exchange between two other nodes, it enters a silent state. The node does not broadcast any HELLO or CTS messages, nor respond to RTS messages. The node remains in the silent state until an ACK is seen, sent by the appropriate node matching the exchange of RTS / CTS messages, or until the timer has elapsed, based on a time set in the \verb'config.py' file, currently set to 15 seconds. This timeout was chosen as a worst case scenario for a very long exchange of messages between two nodes, so even an unusually long exchange will not be interrupted. 

\subsection{Pesudocode}
\begin{figure}[h]
\begin{verbatim}
if packet == CTS:
    state = config.QUIET
    # Record the node that sent the CTS 
    # Allowing us to check if any ACKs overheard are correct 
    sendingCTSNode = sender

if state == config.QUIET:
    args = rfm69.receive()
    # Listen for the ACK connected with the node pair
    # Wait for timeout the timer until 
\end{verbatim}
\caption{Abstracted version of the code for medium access control}
\end{figure}



\section{GPS} 
Before integrating the GPS into the system, I ensured that it worked. Several different serial communication protocols were used, staring with SPI. In the end, UART was used as the asynchronicity worked best with the GPS. To ensure that the GPS generated the correct coordinates, I checked that the coordinates given were my location. \\ \\ 
I found that the GPS had a long time to first fix (TTFF) when started. This was because there was no long term memory when power was lost to the device, so any real time clock (RTC) and downloaded almanac data would be lost. A holder for and CR1220 coin cell were added to allow the GPS to keep accurate RTC data when the system was powered off. This significantly reduced the TTFF. 
% TODO talk about the easy thing on the data set
% cold statrt
%NMEA messages


\subsection{Precision}
To test the tracking on the GPS, a short program was written to generate GPX files. A brief walk was tracked with the GPS. For comparison, the same activity was tracked with a smart watch. Figures 3.4 and 3.5 show the GPX files overlaid on Google Maps. \\
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{gps1.jpg}
\end{center}
\caption{The first attempt at tracking a walk with GPS. The red line is the GPX track generated by the board, the blue line is the GPX track generated by a smartwatch \cite{googlemapsgeneral}}
\end{figure}\\ 
As can be seen from Figure 3.4, the track generated by the system's GPS was jagged and inaccurate. On examination of the GPS coordinates generated by the board, they are only precise to five significant figures, so it is unsurprising that the coordinates are not precisely accurate. Therefore, the degrees and minutes were combined to generate more precise coordinates, to eight significant figures. Figure 3.5 shows the GPX track with the more accurate coordinates. Based on the route taken when walking, the board's GPX track is slightly more accurate than the smartwatch's. 
\begin{figure} [h]
\begin{center}
\includegraphics[scale=0.4]{gps2.jpg}
\end{center}
\caption{The final attempt at tracking a walk with GPS. The red line is the GPX track generated by the board, the blue line is the GPX track generated by a smartwatch \cite{googlemapsgeneral}}
\end{figure}
\FloatBarrier

\subsection{Haversine Formula}
The haversine formula was used to calculate the distance between two sets of GPS coordinates. This was chosen as it is relatively simple to compute. The haversine formula is very commonly used to find distance between two sets of GPS coordinates \cite{haversine}. It is notable that this formula finds two points on a sphere, and the earth is an ellipsoid. The radius of the earth is not consistent across the globe. The average radius of the earth was used instead. As this is an approximation, it will result in errors of up to 0.5\% \cite{gps}. As the distances being measured are relatively small, this was not a problem. Should the system be moved to other planets with a GPS satellite system, this radius will have to be changed. Luckily, this is unlikely due to the absence of interstellar rowing. \\ %TODO remove this sentence
Vincenty's formulae takes the ellipsoidal nature of the earth into consideration, but is more complicated and due to the small distances involved it was decided that the saving made on compute time would be more beneficial than the additional accuracy in distance measurements. \\
\subsubsection{Equations}
The haversine is defined: \\
$haversine(\theta) = sin^2(\theta/2)$ \\ \\ 
Where $\phi$ is latitude and $\lambda$ represents longitude and $haversine(\theta)$ is abbreviated to $hav(\theta)$. \\
$hav(\theta) = hav(\phi_2 - \phi_1) + cos(\phi_1) cos(\phi_2) hav(\lambda_2 - \lambda_1)$ \\
$\theta$ is the angle between the two points on the sphere. $d$ is the distance between the points and $r$ is the radius of the sphere. \\
$\theta = d / r$ \\ \\ 
Combining these equations gives us the distance between the two points as \\
$d = r * 2 * sin^{-1}(\sqrt{sin((\phi_2 - \phi_1)/2))^2 + cos(\lambda_1) * cos(\lambda_2) * sin((\lambda_2 - \lambda_1)/2))^2})$

\subsection{Satellite Error}
It was found that the GPS location moved even when the board was stationary. I believed this to be an error in the library, perhaps related to the precision of floating point numbers. However, research indicated that the noise at the receiver was due to the clock phase noise and interpolation of ephemeris data \cite{satellite}. Implementing a Gaussian or Kalman filter to remove some of the noise would be possible and is further work. Another solution to this problem is demonstrated by the telemetry in the Boat Race, where an external antenna is uses and compared to the values from a base station that has been previously gathering data.  %In the meantime it is necessary to accept a small quantity of error in the reading. %After attempting to debug this and talking to the gentleman who took GPS measurements for the Oxford Cambridge Boat Race, I discovered that this is a limitation of the technology, and that as satellites move across the sky they generate noise in the readings. In their solution to this problem, the Boat Race sets their own base station up at the end of the course, uses an external antenna and a  reads from the GPS up to 20 times a second. They then feed this data through a Kalman filter to give the final value for location. Implementing a Gaussian or Kalman filter to remove some of the noise from the GPS would be possible in this system and is further work. In the meantime it is necessary to accept a small quantity of error in the reading. 
 
 
\section{MicroPython}
The libraries to allow rudimentary interface with the RFM69 and GPS boards were both written in CircuitPython. I opted to use these libraries to interface with this hardware rather than write my own libraries. \\ 
MicroPython supports both multithreading and interrupts, neither of which CircuitPython supports. It was therefore prefered to use MicroPython to implement the core of the system, particularly so the application and networking threads could run concurrently, maximally utilising the two cores in the Raspberry Pi Pico \cite{rp2040}. I ensured the Raspberry Pi Pico could run two threads by defining two functions that calculate the Fibonacci sequence using two global variables and a lock to ensure concurrency control. This code successfully calucalted the Fibonacci sequence when I allocated a thread to each core. \\ \\ 
CircuitPython should have a library, Blinka \cite{blinka}, that emulates the CircuitPython API, and allows hardware operating in CircuitPython to work with MicroPython. However, when attempting to run a simple sending packet and receiving packet setup, I found the code did not work. To debug this problem, I ran two nodes trying to send messages to each other one running CircuitPython and one running MicroPython with the Blinka libraries. A third node read any packets that were sent and logged them. The MicroPython node continued not to receive or send any data. I lowered the baud rate in case the Blinka or SPI interfaces were being overwhelmed. Even with a dramatic reduction, no change was found. \\
This was when my supervisor kindly lent me his expertise and logic analyser. We found that while the Pico was sending data to the RFM69, it was sending it twice, and the RFM69 clearly did not know how to deal with this so did not respond. \\ \\
Rather than trawl through the Blinka library looking for the bugs that caused this, we decided instead to use CircuitPython for the whole system. This meant it had to be redesigned to run on only one core. This ensured project time was spent working on the system, rather than searching for a bug. 


\section{User Interface}
\subsection{Hardware Choice}
In order for the MANET and GPS to be useful, a rudimentary user interface was built. The plan initially contained only a buzzer and button. An LED was added to allow the device to be more accessible for those who cannot hear the buzzer. 
Therefore, a button with a built in LED was chosen. This kept the design of a node simple, so easy to construct, and less likely to get moisture inside the box. The button chosen was also waterproof, the system will get wet in rowing boats. It was a momentary, non-locking, relatively large button to allow the user to effortlessly press it when they encounter an obstacle. \\
A 2k$\Omega$ resistor was chosen to be used in series with the buzzer. This resistance modulates the tone of the buzzer. A brief survey of rowers indicated the eventual tone to be most suitable as a warning. 

\subsection{Integration}
The buzzer and LED were wired in parallel to the same pin in the Pico, to allow the flashing and buzzing to occur simultaneously. If the system detected that the current GPS position of the node was within the distance specified by the \verb'GPS_DISTANCE' value in \verb'config.py', using the haversine formula. (TODO - writing diagram) \\ \\ 
As CircuitPython does not allow interrupts, the value of the button was polled. If the value was true, the button was pressed. The value was polled again after 0.5 seconds. If the value was still true, this was considered to be a `long' press, meaning the obstacle that had been detected should be marked as urgent and propagated through the network at an accelerated rate. (TODO - code snippet?) \\ \\
With the user interface integrated, the third success criteria, \emph{`An application layer had been implemented to allow utility of the network'}, was achieved. 

\subsection{Testing}
The testing of the user interface first ensuring each piece of hardware worked. I wrote a short program to flash the LED and sound the buzzer when the button was pressed. \\
The next stage of testing ensured the system generated new obstacles, adding them to the message buffer, when the button was pressed. This was done by generating messages and ensuring that these messages were received by nearby nodes.  \\ \\
A surprising issue occurred when a node was powered from a power bank, where the node would shut down in a nondeterministic fashion. After experimenting with other power packs and powering the node from mains power, I decided that the power bank likely had some fail safe if a certain level of current was drawn from the power pack, it shut off power as a safety concern. This was rectified by using a different power bank, although batteries could also be used.  

\section{Repository Overview}
%The implementation chapter should include a section labelled "Repository Overview". The repository overview should be around one page in length and should describe the high-level structure of the source code found in your source code repository. It should describe whether the code was written from scratch or if it built on an existing project or tutorial. Making effective use of powerful tools and pre-existing code is often laudable, and will count to your credit if properly reported. Nevertheless, as in the rest of the dissertation, it is essential to draw attention to the parts of the work which are not your own.
(TODO) Typeset more nicely
\begin{verbatim}
(doc) LICENCE
(doc) README.md

(file) Development
    (file) Application
    (file) MACEpidemic
    (file) Misc
    Contains the code used in development of the system. MACEpidemic and 
    Application contain the code generated when building the MANET and 
    interface to it respectively. Misc contains a more varied set of files, 
    generated when trying out hardware and other small components 
    of the system.  

(file) Evaluation
    Split into various folders depending on the evaluation being conducted. 
    It contains the code used to run each subsection of the evaluation, 
    results and python files for analysis of the results. 

(file) OnDevice
    (file) lib
    (doc) boot.py 
    This is the final product, the code that should be uploaded to the Raspberry 
    Pi Pico. The boot.py file contains the implementation of the system to help 
    avoid collisions. The lib file contains adafruit_gps.py, a library I use, 
    licenced under the MIT licence. rfm69.py is a modified version of 
    adafruit_rfm69.py, which I have modified to include fixed length packets 
    and fixed some bugs, so it is a combination of code I wrote and others' code. 
 \end{verbatim}

%%% EVALUATION %%%
\newchapter{4}{Evaluation}
\setcounter{figure}{0}
The majority of the evaluation was conducted according to the plan in Appendix B [\hyperref[appendixB]{Appendix B}]. It was split into a performance evaluation of the MANET and then a more qualitative evaluation of the whole system. \\ \\
%TODO - an overrveiw of the whole system


\section{Evaluating the MANET}
The evaluation of the MANET was designed to mirror the evaluation performed by Vahdat and Becker's paper, with the key difference that my project was implemented in hardware, while theirs was simulated. \\

\subsection{Latency}
The latency of the system was as the time between a node being generated at node A and received at node B. Node B was then moved further away from node A, eventually moving to 500m away with an interim node, C. The distances between nodes were 0, 10, 100, 250 and 500 metres. 60 messages were generated by A at each distance. Figure 4.1 shows the setup, with radio connections between nodes marked in blue. \\ \\ 
\begin{figurehere}
\begin{center}
\begin{tikzpicture}[a/.style={circle, draw=black, very thick, minimum size=17mm},]
\node[a]      (maintopic)                              {\Huge A};
\node[a]        (uppercircle)       [right =3cm  of maintopic] {\Huge B};
\draw[line width=0.5mm, blue] (maintopic) -- (uppercircle);
\end{tikzpicture} \\
\begin{tikzpicture}[
a/.style={circle, draw=black, very thick, minimum size=17mm},]
%Nodes
\node[a]      (maintopic)                              {\Huge A};
\node[a]        (morenode)       [right =3cm  of maintopic] {\Huge C};
\node[a]        (uppercircle)       [right =3cm  of morenode] {\Huge B};

%Lines
\draw[line width=0.5mm, blue] (maintopic) -- (morenode);
\draw[line width=0.5mm, blue] (morenode) -- (uppercircle);
\end{tikzpicture}
\end{center}
\caption{The network used for latency testing}
\end{figurehere}
\FloatBarrier
\bigskip
Figure 4.2 shows the percentage of packets delivered over time. Figure 4.3 breaks down the data behind this, showing the times that each packet arrived at each distance. It is unsurprising to find that the charts for 0 and 10 metres differ little, with an average delivery time of 15.0 and 15.7 seconds respectively. The 100 metre interval follows a similar pattern. There is then a significant drop-off when the distance is increased to 250 and 500 metres, likely because more than one hop needed to be used to move messages from one node to another. There is a significant increase in the standard deviation, due to the increased variability from passing messages over multiple nodes. \\ \\
%TODO relate to the speed of rowing boats being 
\begin{figure}[h]
\begin{center}
\input{percentages.pgf}
\end{center}
\caption{The percentage of packets delivered with time}
\end{figure}

\begin{figure}[h]
\begin{center}
\input{distanceIntervals.pgf}
\end{center}
\caption{The time taken to deliver messages over distance intervals}
\end{figure}
\begin{table}[h]
\begin{center}
\begin{tabular}{ |r|r|r| } 
\hline
Distance & Average Latency /Seconds & Standard Deviation /Seconds \\ 
\hline
0 & 15.045 & 13.796 \\ 
\hline
10 & 15.703 & 16.199 \\ 
\hline
100 & 34.914 & 37.966 \\ 
\hline
250 & 151.741 & 126.721 \\ 
\hline
500 & 233.357 & 138.679 \\ 
\hline
\end{tabular}
\end{center}
\caption{Average delivery and standard deviation in seconds}
\end{table} 





\subsection{Bandwidth}
Testing the bandwidth of the system was done with the aim of working out how many messages the system can cope with. In reality, it is unlikely the MANET will need to process as many messages as in this test. Bandwidth testing was conducted between two nodes, with one node generating messages at a set rate and broadcasting them to the other node. Messages were generated at an increasing rate until the number of messages received by node B plateaued. Figure 4.4 shows the setup for this test. \\ \\
As shown in Figure 4.5, the MANET has a relatively low bandwidth, with plateauing at around 0.35 messages transferred on average each second, equivalent to taking around 3 seconds to pass one message from node to node. To improve the bandwidth of the system, I could decrease the time between discovery (`hello') packets sent by each node. 

\begin{figurehere}
\begin{center}
\begin{tikzpicture}[
node/.style={circle, draw=black, very thick, minimum size=17mm},
]
%Nodes
\node[node]      (maintopic)         {\Huge A};
\node[node]        (uppercircle)       [right =3cm  of maintopic] {\Huge B};

%Lines
\draw[line width=0.5mm, blue] (maintopic) -- (uppercircle);
\end{tikzpicture} 
\end{center}
\caption{The network used for bandwidth testing}
\end{figurehere}

\begin{figure}
\begin{center}
\input{bandwidth.pgf}
\end{center}
\caption{The bandwidth of a fully connected two node network with an increasing number of messages generated each second (TODO - extend to 10)}
\end{figure}

\subsection{Percentage of Packets Delivered}
With the exception of bandwidth testing, when more packets were generated than could be delivered, 100\% of packets were delivered throughout testing. This mirrors the results found by Vahdat and Becker, where their simulation gave a 100\% delivery rate when the number of messages was smaller or equal to the size of the message buffer. \\
The percentage of packets delivered is best illustrated by the test with five nodes. To run this test, I recruited four volunteers to move around a large field, approximately 500 x 500 metre area. This allowed nodes to move in and out of range of each other. Each node had a 0.1 probability of generating a message, with up to 30 messages being generated. The nodes moved around this test area for approximately 15 minutes. This is a reduced version of the evaluation performed in Vahdat and Becker's paper \cite{epidemic}, where 50 nodes were simulated within a 1500 x 300 metre area. \\
While this test was run three times, only two of the results can be used due to a loose connection meaning a node did not work on the second run. In both these tests, 100\% of packets were delivered.
% TODO perhpas do a perentage delivered over time or something? IDK 
% TODO you can definately do better stats on this 
% ADD a diagram

\subsection{Partitions}
The network was broken into smaller networks to ensure that messages are propagated through the network after partition and compare the time taken to propagate messages after partition. \\
Partition evaluation was conducted with four nodes. The first experiments used two pairs. Each pair was set up to communicate with each other, then brought into range of the other pair. Figures 4.6 and 4.7 show the starting and finishing states of the network. 
\begin{figurehere}
\begin{center}
\begin{tikzpicture}[
a/.style={circle, draw=black, very thick, minimum size=17mm},
]
\node[a] (aa) {\Huge A};
\node[a] (bb) [below=2cm of aa] {\Huge B};
\node[a] (cc) [right=5cm of aa] {\Huge C};
\node[a] (dd) [right=5cm of bb] {\Huge D};
\draw[line width=0.5mm, blue] (aa) -- (bb);
\draw[line width=0.5mm, blue] (cc) -- (dd);
\end{tikzpicture}  \\
\end{center}
\caption{The network at the start of partition testing}
\end{figurehere}
\FloatBarrier
\begin{figurehere}
\begin{center}
\begin{tikzpicture}[
a/.style={circle, draw=black, very thick, minimum size=17mm},
b/.style={circle, draw=black, very thick, minimum size=17mm},
c/.style={circle, draw=black, very thick, minimum size=17mm},
d/.style={circle, draw=black, very thick, minimum size=17mm},
]
%Nodes
\node[a] (aa) {\Huge A};
\node[b] (bb) [below=2cm of aa] {\Huge B};
\node[c] (cc) [right=2cm of aa] {\Huge C};
\node[d] (dd) [right=2cm of bb] {\Huge D};

%Lines
\draw[line width=0.5mm, blue] (aa) -- (bb);
\draw[line width=0.5mm, blue] (aa) -- (cc);
\draw[line width=0.5mm, blue] (aa) -- (dd);
\draw[line width=0.5mm, blue] (bb) -- (dd);
\draw[line width=0.5mm, blue] (bb) -- (cc);
\draw[line width=0.5mm, blue] (cc) -- (dd);
\end{tikzpicture} 
\end{center}
\caption{The network at the end of partition testing}
\end{figurehere}
\FloatBarrier

\subsubsection{Asymmetric}
Asymmetric partition testing consisted of the \{A, B\} pair holding 30 messages before partition. After the partition was removed, the \{C, D\} pair held the same messages \{A, B\} held. Over 2 partitions, the average time taken for all nodes in the network to hold the same messages was 106.5 seconds. Given the approximate speed of a rowing boat is 15km/h, and the radio range is 500 meters, this would allow two boats to be in range for 120 seconds, just enough time for the maximum number of messages to be transferred between two boats.  \\ \\
\begin{table}
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Run & Time for Node C (seconds) & Time for Node D (seconds) \\ 
\hline
1 & 50 & 135 \\ 
\hline
2 & 78 & 44  \\ 
\hline
\end{tabular}
\end{center}
\caption{Time taken for all messages to be received in asymmetric partitions}
\end{table}  

\subsubsection{Symmetric}
Symmetric evaluation of the network gave the two pairs of nodes different sets of messages.
The average time for nodes to receive all 30 messages was 130 seconds, 23.5 seconds greater than an asymmetric partition.
\begin{table}
\begin{center}
\begin{tabular}{ |c|c|c|c| } 
\hline
Node A & Node B & Node C & Node D \\ 
\hline
87 & 159 & 145 & 129 \\ 
\hline
\end{tabular}
\end{center}
\caption{Time taken in seconds for all messages to be received in symmetric partitions}
\end{table}  

% TODO the four node partition where everyone joins

\section{Evaluating the System}
\subsection{On Water} 
The water evaluation was conducted last. I was concerned that there might be an accident and the project become water damaged or fall into the river, so all experiments before this were conducted on land. The system works on rowing boats, notifying rowers of other boats who are using the system and of registered obstacles. \\ \\ 

\subsubsection{GPS}
Rivers and lakes are in many ways ideal for the GPS, being large open spaces with few obstacles to the system's view of the sky. However, I was concerned that bridges or similar obstructions to the sky would interfere with the GPS tracking on each boat. This would be of particular concern as a bridge could be considered an obstacle. I therefore examined the GPS tracking on the water by logging the location at regular intervals in a GPX file. \\
Figure 4.7 shows the GPS trace underneath a bridge. While the error caused by the bridge is minimal, it could be improved by applying a Gaussian or Kalman filter, as done in other GPS tracking for rowing boats. An issue this experiment inadvertently highlighted is that the trace does not appear to be accurate, showing the boat moving along the ground at some points. When comparing this to the GPS points taken in later experiments, this does not seem to be a systematic error, but rather a random error in the placement of the GPS in that outing. This suggests that an obstacle may be recorded in the wrong place due to an inaccurate GPS reading.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{bridgeGPS.jpg}
\end{center}
\caption{The GPS track taken by a node, shown on Google Maps \cite{googlemapsgeneral}}
\end{figure}

\subsubsection{Crash Prevention on Water}
To ensure the system worked in the use case environment, I went rowing with a volunteer, each of us with a device on our boat. We ensured that the boats were notified when they were approaching each other. We found this notification to come at around 10 metres between boats. However, when the boats are rowing alongside one another, with no chance of collision, they continually alert the user to the other boat. \\ \\ % TODO - unique ID so this does not occur
The nodes also transfer knowledge of obstacles between them. To test this, one boat went further up the river and registered a `new obstacle' at a pre-agreed point (shown in Figure 4.8, opposite the Goldie Boat House) by pressing the button on the device. The first boat then returned to the second, which moved towards the potential obstacle. This gave a time delay between the boats approaching the obstacle, showing that messages are propagated through the network to warn other boats of the obstacles. The node warned the other boat of the obstacle. 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{obstacle.jpg}
\end{center}
\caption{The registered obstacle as a red marker on Google Maps \cite{googlemapsgeneral}}
\end{figure}

\subsection{Qualitative Evaluation}
\subsubsection{Survey}
For a qualitative evaluation, I surveyed the rower in the other single. While their overall impression was positive, the survey highlighted extra work that needed to be done to the user interface. They pointed out that the buzzer, even if the bug for notifying users about boats they are rowing alongside is fixed, might be a violation of rules about noise during certain times, so it could include another button to turn off the buzzer if needed.

\subsubsection{Limitations Caused by Implementation}
There are some limitations to the system due to its design. The format of the packets has meant that there can be at most 255 nodes in the system, as there are two bytes reserved for the node address and address 0 is reserved for broadcast. The number of obstacles stored in memory is limited by the available memory on the chip, 1.9MB as 1MB is dedicated to the code running the node. Assuming each obstacle takes 10 bytes, 95000 obstacles can be stored on a device. This is sufficient. However, the message buffer is limited to 30. This limit on the number of messages a node can propagate is placed there to allow the unique ID for each message to fit into a single 64 byte packet, but means that the maximum number of obstacles a node can pass to a neighbour is 30.

%%% CONCLUSION %%%
\newchapter{5}{Conclusion}
\setcounter{figure}{0}
\section{Achievements}
In the introduction I highlighted the issues around crashes in rowing boats and the need for a system to help prevent such crashes. This dissertation has presented such a system, propagating knowledge about obstacles through a network of rowing boats using the Epidemic routing protocol. Figure 5.1 shows a node from the final product, a box attached to a single scull.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.15]{boxOnBoat.jpeg}
\end{center}
\caption{The final product in use, attached to the canvas of a rowing boat}
\end{figure}
\FloatBarrier
Three success criteria were laid out as part of the preparation: \\
{\begin{tabular}{ll}
The Epidemic routing protocol is implemented within the network\\
An evaluation of the network has been carried out\\
An application layer has been implemented to allow utility of the network \\
\end{tabular} \\ \\
This project has met and exceeded the success criteria. Amongst the extension criteria achieved, medium access control was implemented, high and low priority messaging was defined within Epidemic routing, and a review of the application layer was conducted. \\ \\
As part of this project, I have contributed to open source libraries and furthered my knowledge of microcontrollers, GPS and networking. 

\section{Reflections}
The preparation chapter lays out the choices I made with respect to the software development methodology, tools and programming language. These choices were all found to be effective in designing and building the system. It was particularly helpful to have a plan that split the project into stages with defined deliverables at each stage. \\ \\ 
While the research phase is designed to cover broad parts of the area in order to find the best solution to a problem, I spent too much time researching various potential routing protocols. With the benefit of hindsight, it would have been beneficial to settle on the Epidemic routing protocol earlier in the process. \\ \\
There were both upsides and downsides to implementing the project in hardware. It taught me huge amounts 
about serial communication protocols and other low level implementation details. It also allowed for a more holistic approach to the evaluation, using the system on rowing boats. However, it is undeniable that the low level details made some aspects of the project more difficult, particularly when it came to debugging a problem. For instance, I soldered an antenna to a radio module in such a way that caused errors in the received packets, a problem I did not diagnose until I swapped the module for another one. 

\subsection{Other Approaches}
There have been other approaches to this problem. ROWCUS used radar to attempt to solve this problem. This technological approach has the benefit that no person has to mark the location of an obstacle to be warned of it but is likely to miss some obstacles, particularly those submerged underneath the water, arguably the most dangerous obstacles as the users cannot see them. ROWCUS has ``decided not to pursue'' their system any further.

\section{Future Work}
There is future work that could be conducted in relation to both the networking and application components of the project. \\ \\
Some of the networking extensions were drawn from my research into networking protocols other than Epidemic. For instance, as in GPSR, the GPS location could be used, either by only contacting nearby nodes to increase the probability that an anti-entropy session is successful. The location could also be used to prioritise sending messages about new obstacles to nodes that are near these obstacles.  A metric for transmission quality, in radio communication the received strength signal indicator (RSSI), to influence whether an anti-entropy session was initiated. \\ \\ 
The application component could be further improved by taking the direction of the rowing boat into account when notifying the user of an obstacle. The GPS could be further improved by applying a Gaussian or Kalman filter to reduce the noise in the location, particularly under bridges. Additional improvements could be made from the suggestions of users, such as a switch to mute the buzzer. 

\section{Other applications}
Such a system could be utilised for other applications. The most obvious is collision avoidance for other water sports, such as canoeing and kayaking. There are more avant-garde applications for this system, for instance decide if boats have collided within competitions, removing human bias. The low latency may be a concern in other uses of the system. 

%%% BIBLIOGRAPHY  %%%
% TODO -- why has this kille any capitalization in
% the names of the references? E.g. DARPA
\bibliographystyle{IEEEtran}
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{refs}


%%% APPENDICES %%%
\chapter*{Appendices}
\addcontentsline{toc}{chapter}{Appendices}  

\section*{A -- Guide to Building a Node}
\label{appendixA}
\addcontentsline{toc}{section}{A -- Guide to Building a Node}  
\setcounter{chapter}{0}
\setcounter{figure}{0}
\input{README}

\newpage
\section*{B -- Evaluation Plan}
\label{appendixB}
\addcontentsline{toc}{section}{B -- Evaluation Plan}  
\setcounter{figure}{0}
\input{evaluationPlan}

\newpage
\section*{C -- Progress Report}
\label{appendixC}
\addcontentsline{toc}{section}{C -- Progress Report}  
\setcounter{figure}{0}
\input{progressReport}

\newpage
\section*{D -- Project Proposal}
\label{appendixD}
\addcontentsline{toc}{section}{D -- Project Proposal}  
\setcounter{figure}{0}
\input{phase3}

\end{document}